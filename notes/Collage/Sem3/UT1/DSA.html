<!DOCTYPE html>
<html lang="en">
	<head>
		<title>DSA - AK#Notes</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover">
		<meta name="author" content="AnzenKodo">
		<meta name="theme-color" content="#FF6C22">
		<meta name="description" content="## 1.A) 6 Marks  ### i) Illustrate an algorithm to count number of nodes in singly linked list.  ```">
		<meta property="og:description" content="## 1.A) 6 Marks  ### i) Illustrate an algorithm to count number of nodes in singly linked list.  ```">
		<meta property="og:image" content="https://AnzenKodo.github.io/assets/favicon/notes.png">
		<meta property="og:image:alt" content="AK#Notes logo">
		<meta property="og:site_name" content="AK#Notes">
		<meta property="og:title" content="DSA - AK#Notes">
		<meta property="og:url" content="https://AnzenKodo.github.io/notes/notes/Collage/Sem3/UT1/DSA.html">
		<meta property="og:type" content="article">
		<meta property="og:article:author" content="AnzenKodo">
		<link rel="icon" type="image/png" href="https://AnzenKodo.github.io/assets/favicon/notes.png">
		<style>
			*,::after,::before{box-sizing:border-box}html{font-family:ui-serif, serif;line-height:1.15;-webkit-text-size-adjust:100%;-moz-tab-size:4;tab-size:4}body{margin:0}hr{height:0;color:inherit}abbr[title]{text-decoration:underline dotted}b,strong{font-weight:bolder}code,kbd,pre,samp{font-family:ui-monospace,SFMono-Regular,Consolas,'Liberation Mono',Menlo,monospace;font-size:1em}small{font-size:80%}sub,sup{font-size:75%;line-height:0;position:relative;vertical-align:baseline}sub{bottom:-.25em}sup{top:-.5em}table{text-indent:0;border-color:inherit}button,input,optgroup,select,textarea{font-family:inherit;font-size:100%;line-height:1.15;margin:0}button,select{text-transform:none}[type=button],[type=reset],[type=submit],button{-webkit-appearance:button}::-moz-focus-inner{border-style:none;padding:0}:-moz-focusring{outline:1px dotted ButtonText}:-moz-ui-invalid{box-shadow:none}legend{padding:0}progress{vertical-align:baseline}::-webkit-inner-spin-button,::-webkit-outer-spin-button{height:auto}[type=search]{-webkit-appearance:textfield;outline-offset:-2px}::-webkit-search-decoration{-webkit-appearance:none}::-webkit-file-upload-button{-webkit-appearance:button;font:inherit}summary{display:list-item}

			:root {
				/* color-scheme: dark light; */
				color-scheme: dark;
				--theme: #FF6C22;
			}
			body {
				max-width: 40rem;
				margin: 0 auto;
				font-family: system-ui;
				padding: 0 1em;
				color: inherit !important;
				word-break: break-word;
			}
			h1, h2, h3, h4, h5, h6 {
				font-family: monospace;
				margin: 2rem 0 0.5rem 0;
			}
			h2 {
				font-size: 2rem;
			}
			h3 {
				font-size: 1.8rem;
			}
			h4 {
				font-size: 1.5rem;
			}
			h5 {
				font-size: 1.3rem;
			}
			h6 {
				font-size: 1rem;
			}
			p, li, td, code {
				line-height: 1.5rem;
			}
			a {
				color: var(--theme);
				text-decoration: none;
			}
			a:hover, a:focus {
				text-decoration: underline;
			}
			a:active {
				background: var(--theme);
				color: inherit;
			}
			ul ul, ul ol, ol ol, ol ul {
				margin-top: .5rem;
			}
			li {
				margin-bottom: .5rem;
			}
			table {
				border-collapse: collapse;
				overflow-x: auto;
				display: block;
				word-break: auto-phrase;
				margin: 1rem 0;
			}
			th {
				font-size: 1.1rem;
				border: 2px solid;
				padding: .3rem .3rem;
			}
			td {
				border: 1px solid;
				padding: .3rem .5rem;
			}
			blockquote {
				margin-left: 0;
				margin-right: 0;
				border: 1px solid;
				border-left: 10px solid;
				padding: 0 1rem;
			}
				.code-block {
				background: black;
				overflow-x: auto;
				padding: 0em 1em;
				border: 1px solid;
			}
			.code-block-language-name {
				position: sticky;
				left: 95%;
				top: .5em;
				font-weight: bold;
				color: white;
			}
			:not(pre.chroma) > code {
				border: 1px solid;
				padding: .3rem .2rem .2rem .2rem;
			}
			img {
				max-width: 100%;
				display: block;
				margin: 0 auto;
			}
			[href="#skip-top-main"] {
				padding: 0.3em;
				position: absolute;
				transform: translateY(-1000%);
			}
			[href="#skip-top-main"]:focus {
				transform: translateY(0%);
				background: var(--theme);
				color: inherit;
			}
			#table-of-content {
				position: fixed;
				bottom: 10px;
				right: 10px;
				background: black;
				padding: 0.5rem 1em;
				z-index: 1;
				color: white;
			}
			#table-of-content[open] {
				max-height: 90%;
				overflow-y: auto;
				bottom: 50px;
				margin-left: 1em;
			}
			#table-of-content[open] summary {
				background: black;
				padding: 0.5em 1em;
				text-align: center;
				position: fixed;
				bottom: 10px;
				right: 10px;
			}
			#table-of-content ul:first-child {
				padding-left: 1em;
				margin-top: 1.5em;
			}
			.heading-anchor::before {
				content: "#";
				margin-right: .5rem;
			}
			.mermaid {
				background: black;
				border: 1px solid;
				margin-top: 1rem;
				padding: 1rem;
				font-family: monospace;
			}
			.mermaid svg {
				display: block;
				margin: auto;
			}
			.mermaid:has(svg) {
				background: none;
				border: none;
				margin-top: 1rem;
				padding: 0;
			}
			mjx-container {
				display: math;
				overflow-y: hidden;
				overflow-x: auto;
				max-width: 100%;
				padding-bottom: .8rem;
			}
			iframe {
				width: 100%;
				height: 21rem;
				margin: 1rem 0;
			}
			video {
				width: 100%;
			}
		</style>
	</head>

	<body>
		<a href="#skip-top-main">Skip to main</a>
		<header>
<!--		<h1 style="text-align: center;">-->
			<h1 style="text-align: center;">
				<a href="https://AnzenKodo.github.io">AK</a>#<a href="https://AnzenKodo.github.io/notes">Notes</a>
			</h1>
            <video width="100%" controls>
                <source src="https://anzenkodo.github.io/drive/london.mp4" type="video/mp4">
            </video><nav style="border-top: 1px solid gray;border-bottom: 1px solid gray;padding: .5rem 0;text-align: center;margin: 0 0 2rem 0;color: gray;clear: left;line-height: 1.6rem;">
				<a href="https://AnzenKodo.github.io/notes">Home</a> | <a href="https://AnzenKodo.github.io">About</a> | <a href="https://AnzenKodo.github.io/blogroll">Blogroll</a> | <a href="https://github.com/AnzenKodo">Github</a> | <a href="https://x.com/AnzenKodo">ùïè</a>
			</nav>
			<!-- <img src="https://AnzenKodo.github.io/assets/driftnet.png" alt="DriftNet Sponsored Image" style="margin: 1rem 0 1.5rem 0;"> -->
		</header>
		<main id="skip-top-main">
			<h1 style="font-size: 2.3rem; margin-top: 0;">DSA</h1>
			<h2><a name="1-a-6-marks" class="heading-anchor" href="#1-a-6-marks" rel="nofollow" aria-hidden="true"></a>1.A) 6 Marks</h2><h3><a name="i-illustrate-an-algorithm-to-count-number-of-nodes-in-singly-linked-list" class="heading-anchor" href="#i-illustrate-an-algorithm-to-count-number-of-nodes-in-singly-linked-list" rel="nofollow" aria-hidden="true"></a>i) Illustrate an algorithm to count number of nodes in singly linked list.</h3>
<div class="code-block"><html>
<style type="text/css">
/* Background */ .bg { color: #282c34 }
/* PreWrapper */ .chroma { color: #c9c9c9color: #282c34; }
/* Other */ .chroma .x { color: #c9c9c9 }
/* Error */ .chroma .err { color: #cf5967 }
/* CodeLine */ .chroma .cl { color: #c9c9c9 }
/* LineTableTD */ .chroma .lntd { vertical-align: top; padding: 0; margin: 0; border: 0;color: #c9c9c9 }
/* LineTable */ .chroma .lntable { border-spacing: 0; padding: 0; margin: 0; border: 0;color: #c9c9c9 }
/* LineHighlight */ .chroma .hl { color: #c9c9c9; background-color: #e5e5e5 }
/* LineNumbersTable */ .chroma .lnt { white-space: pre; user-select: none; margin-right: 0.4em; padding: 0 0.4em 0 0.4em;color: #939599 }
/* LineNumbers */ .chroma .ln { white-space: pre; user-select: none; margin-right: 0.4em; padding: 0 0.4em 0 0.4em;color: #939599 }
/* Line */ .chroma .line { display: flex;color: #c9c9c9 }
/* Keyword */ .chroma .k { color: #7fbaf5 }
/* KeywordConstant */ .chroma .kc { color: #cf5967; background-color: #43454f }
/* KeywordDeclaration */ .chroma .kd { color: #7fbaf5 }
/* KeywordNamespace */ .chroma .kn { color: #bc74c4 }
/* KeywordPseudo */ .chroma .kp { color: #bc74c4 }
/* KeywordReserved */ .chroma .kr { color: #7fbaf5 }
/* KeywordType */ .chroma .kt { color: #57c7ff; font-weight: bold }
/* Name */ .chroma .n { color: #c9c9c9 }
/* NameAttribute */ .chroma .na { color: #bc74c4 }
/* NameBuiltin */ .chroma .nb { color: #7fbaf5 }
/* NameBuiltinPseudo */ .chroma .bp { color: #7fbaf5 }
/* NameClass */ .chroma .nc { color: #ecbe7b }
/* NameConstant */ .chroma .no { color: #ecbe7b }
/* NameDecorator */ .chroma .nd { color: #ecbe7b }
/* NameEntity */ .chroma .ni { color: #c9c9c9 }
/* NameException */ .chroma .ne { color: #cf5967 }
/* NameFunction */ .chroma .nf { color: #57c7ff }
/* NameFunctionMagic */ .chroma .fm { color: #c9c9c9 }
/* NameLabel */ .chroma .nl { color: #cf5967 }
/* NameNamespace */ .chroma .nn { color: #c9c9c9 }
/* NameOther */ .chroma .nx { color: #c9c9c9 }
/* NameProperty */ .chroma .py { color: #c9c9c9 }
/* NameTag */ .chroma .nt { color: #bc74c4 }
/* NameVariable */ .chroma .nv { color: #bc74c4; font-style: italic }
/* NameVariableClass */ .chroma .vc { color: #57c7ff; font-weight: bold }
/* NameVariableGlobal */ .chroma .vg { color: #ecbe7b }
/* NameVariableInstance */ .chroma .vi { color: #57c7ff }
/* NameVariableMagic */ .chroma .vm { color: #c9c9c9 }
/* Literal */ .chroma .l { color: #c9c9c9 }
/* LiteralDate */ .chroma .ld { color: #57c7ff }
/* LiteralString */ .chroma .s { color: #82cc6a }
/* LiteralStringAffix */ .chroma .sa { color: #82cc6a }
/* LiteralStringBacktick */ .chroma .sb { color: #57c7ff }
/* LiteralStringChar */ .chroma .sc { color: #57c7ff }
/* LiteralStringDelimiter */ .chroma .dl { color: #82cc6a }
/* LiteralStringDoc */ .chroma .sd { color: #82cc6a }
/* LiteralStringDouble */ .chroma .s2 { color: #82cc6a }
/* LiteralStringEscape */ .chroma .se { color: #56b6c2 }
/* LiteralStringHeredoc */ .chroma .sh { color: #56b6c2 }
/* LiteralStringInterpol */ .chroma .si { color: #82cc6a }
/* LiteralStringOther */ .chroma .sx { color: #82cc6a }
/* LiteralStringRegex */ .chroma .sr { color: #57c7ff }
/* LiteralStringSingle */ .chroma .s1 { color: #82cc6a }
/* LiteralStringSymbol */ .chroma .ss { color: #82cc6a }
/* LiteralNumber */ .chroma .m { color: #56b6c2 }
/* LiteralNumberBin */ .chroma .mb { color: #57c7ff }
/* LiteralNumberFloat */ .chroma .mf { color: #56b6c2 }
/* LiteralNumberHex */ .chroma .mh { color: #57c7ff }
/* LiteralNumberInteger */ .chroma .mi { color: #56b6c2 }
/* LiteralNumberIntegerLong */ .chroma .il { color: #56b6c2 }
/* LiteralNumberOct */ .chroma .mo { color: #57c7ff }
/* Operator */ .chroma .o { color: #bc74c4 }
/* OperatorWord */ .chroma .ow { color: #bc74c4 }
/* Punctuation */ .chroma .p { color: #56b6c2 }
/* Comment */ .chroma .c { color: #3e4460 }
/* CommentHashbang */ .chroma .ch { color: #3e4460; font-style: italic }
/* CommentMultiline */ .chroma .cm { color: #3e4460 }
/* CommentSingle */ .chroma .c1 { color: #3e4460 }
/* CommentSpecial */ .chroma .cs { color: #bc74c4; font-style: italic }
/* CommentPreproc */ .chroma .cp { color: #7fbaf5 }
/* CommentPreprocFile */ .chroma .cpf { color: #7fbaf5 }
/* Generic */ .chroma .g { color: #c9c9c9 }
/* GenericDeleted */ .chroma .gd { color: #cf5967 }
/* GenericEmph */ .chroma .ge { color: #c9c9c9; text-decoration: underline }
/* GenericError */ .chroma .gr { color: #cf5967; font-weight: bold }
/* GenericHeading */ .chroma .gh { color: #ecbe7b; font-weight: bold }
/* GenericInserted */ .chroma .gi { color: #ecbe7b }
/* GenericOutput */ .chroma .go { color: #43454f }
/* GenericPrompt */ .chroma .gp { color: #c9c9c9 }
/* GenericStrong */ .chroma .gs { color: #cf5967; font-weight: bold }
/* GenericSubheading */ .chroma .gu { color: #cf5967; font-style: italic }
/* GenericTraceback */ .chroma .gt { color: #c9c9c9 }
/* GenericUnderline */ .chroma .gl { color: #c9c9c9; text-decoration: underline }
/* TextWhitespace */ .chroma .w { color: #c9c9c9 }
body { color: #282c34; }
</style><body class="bg">
<pre tabindex="0" class="chroma"><code><span class="line"><span class="cl">Step 1: if head is NULL then
</span></span><span class="line"><span class="cl">          print(&#34;List is empty&#34;)
</span></span><span class="line"><span class="cl">        else
</span></span><span class="line"><span class="cl">Step 3: q = head AND counter = 0
</span></span><span class="line"><span class="cl">Step 2: counter = counter + 1
</span></span><span class="line"><span class="cl">Step 4: Go to next_node
</span></span><span class="line"><span class="cl">Step 5: if q != NULL
</span></span><span class="line"><span class="cl">          Repeat from Step 3
</span></span><span class="line"><span class="cl">Step 6: Return counter
</span></span></code></pre>
</body>
</html>
</div><h3><a name="ii-interpret-following-terminologies-i-node-ii-root-iii-leaf-node" class="heading-anchor" href="#ii-interpret-following-terminologies-i-node-ii-root-iii-leaf-node" rel="nofollow" aria-hidden="true"></a>ii) Interpret following terminologies i) Node ii) Root iii) Leaf Node</h3>
<p><img loading="lazy" src="./Graph-Terminologies.svg" alt="Graph Terminologies Diagram" /></p>

<ul>
<li>i) <strong>Node:</strong> A node is a basic unit of a data in a graph, tree or other data
structure. It can contain a value or data, as well as a reference to other
nodes. In a graph, a node represents a vertex or a point and it can be
connected to other nodes with edges.</li>
<li>ii) <strong>Root:</strong> In a tree data structure, the root is the topmost node that is
the ancestor of all other nodes in the tree. It is the node from which all
other nodes can be reached by following a path down the tree. The root node
does not have any parent.</li>
<li>iii) <strong>Leaf Node:</strong> In a tree data structure, a leaf node is a node that has
no children. It is a node that is located at the bottom of the tree and does
not have any descendant nodes. A leaf node is also called a terminal node.</li>
</ul>
<h3><a name="iii-summarize-any-3-properties-of-b-tree" class="heading-anchor" href="#iii-summarize-any-3-properties-of-b-tree" rel="nofollow" aria-hidden="true"></a>iii) Summarize any 3 properties of B-Tree</h3>
<ul>
<li><strong>Multi-node structure:</strong> B-Trees are multi-node data structures, which means
that the keys are not stored in a single node but are distributed among
multiple nodes. This allows for efficient searching, insertion and deletion
operations.</li>
<li><strong>Balancing:</strong> B-Trees are self-balancing data structures. They automatically
adjust their structure to maintain a certain level of balance, which ensures
that the height of the tree remains small, and the search, insertion and
deletion operations are performed efficiently.</li>
<li><strong>Large number of keys:</strong> B-Trees are designed to efficiently store and
retrieve a large number of keys. Each node in a B-Tree can store multiple
keys, which allows for a high degree of parallelism in searching, insertion
and deletion operations. This makes B-Trees particularly useful in databases
and file systems where large amounts of data need to be stored and retrieved
efficiently.</li>
</ul>

<p><a href="https://youtu.be/KnXohGgIpQU">B-Tree Explaned</a></p>
<h2><a name="1-b-4-marks" class="heading-anchor" href="#1-b-4-marks" rel="nofollow" aria-hidden="true"></a>1.B) 4 Marks</h2><h3><a name="i-describe-linked-list-with-types" class="heading-anchor" href="#i-describe-linked-list-with-types" rel="nofollow" aria-hidden="true"></a>i) Describe Linked List with types.</h3>
<p><img loading="lazy" src="./Linked-List-Types.png" alt="Linked List types graphs" /></p>

<ul>
<li><strong>Singly Linked List:</strong> It is the simplest type of linked list in which every
node contains some data and a pointer to the next node of the same data type.
The node contains a pointer to the next node means that the node stores the
address of the next node in the sequence. A single linked list allows the
traversal of data only in one way.</li>
<li><strong>Doubly Linked List:</strong> A doubly linked list or a two-way linked list is a
more complex type of linked list that contains a pointer to the next as well
as the previous node in sequence, Therefore, it contains three parts of data,
a pointer to the next node, and a pointer to the previous node. This would
enable us to traverse the list in the backward direction as well.</li>
<li><strong>Circular Linked List:</strong> A circular linked list is one in which the last node
contains the pointer to the first node of the list. While traversing a
circular linked list, one can begin at any node and traverse the list in any
direction forward and backward until reaching the same node where it started.
Thus, a circular linked list has no beginning and no end.</li>
</ul>
<h3><a name="ii-illustrate-algorithm-to-display-data-from-circular-linked-list" class="heading-anchor" href="#ii-illustrate-algorithm-to-display-data-from-circular-linked-list" rel="nofollow" aria-hidden="true"></a>ii) Illustrate algorithm to display data from circular linked list.</h3>
<div class="code-block"><html>
<style type="text/css">
/* Background */ .bg { color: #282c34 }
/* PreWrapper */ .chroma { color: #c9c9c9color: #282c34; }
/* Other */ .chroma .x { color: #c9c9c9 }
/* Error */ .chroma .err { color: #cf5967 }
/* CodeLine */ .chroma .cl { color: #c9c9c9 }
/* LineTableTD */ .chroma .lntd { vertical-align: top; padding: 0; margin: 0; border: 0;color: #c9c9c9 }
/* LineTable */ .chroma .lntable { border-spacing: 0; padding: 0; margin: 0; border: 0;color: #c9c9c9 }
/* LineHighlight */ .chroma .hl { color: #c9c9c9; background-color: #e5e5e5 }
/* LineNumbersTable */ .chroma .lnt { white-space: pre; user-select: none; margin-right: 0.4em; padding: 0 0.4em 0 0.4em;color: #939599 }
/* LineNumbers */ .chroma .ln { white-space: pre; user-select: none; margin-right: 0.4em; padding: 0 0.4em 0 0.4em;color: #939599 }
/* Line */ .chroma .line { display: flex;color: #c9c9c9 }
/* Keyword */ .chroma .k { color: #7fbaf5 }
/* KeywordConstant */ .chroma .kc { color: #cf5967; background-color: #43454f }
/* KeywordDeclaration */ .chroma .kd { color: #7fbaf5 }
/* KeywordNamespace */ .chroma .kn { color: #bc74c4 }
/* KeywordPseudo */ .chroma .kp { color: #bc74c4 }
/* KeywordReserved */ .chroma .kr { color: #7fbaf5 }
/* KeywordType */ .chroma .kt { color: #57c7ff; font-weight: bold }
/* Name */ .chroma .n { color: #c9c9c9 }
/* NameAttribute */ .chroma .na { color: #bc74c4 }
/* NameBuiltin */ .chroma .nb { color: #7fbaf5 }
/* NameBuiltinPseudo */ .chroma .bp { color: #7fbaf5 }
/* NameClass */ .chroma .nc { color: #ecbe7b }
/* NameConstant */ .chroma .no { color: #ecbe7b }
/* NameDecorator */ .chroma .nd { color: #ecbe7b }
/* NameEntity */ .chroma .ni { color: #c9c9c9 }
/* NameException */ .chroma .ne { color: #cf5967 }
/* NameFunction */ .chroma .nf { color: #57c7ff }
/* NameFunctionMagic */ .chroma .fm { color: #c9c9c9 }
/* NameLabel */ .chroma .nl { color: #cf5967 }
/* NameNamespace */ .chroma .nn { color: #c9c9c9 }
/* NameOther */ .chroma .nx { color: #c9c9c9 }
/* NameProperty */ .chroma .py { color: #c9c9c9 }
/* NameTag */ .chroma .nt { color: #bc74c4 }
/* NameVariable */ .chroma .nv { color: #bc74c4; font-style: italic }
/* NameVariableClass */ .chroma .vc { color: #57c7ff; font-weight: bold }
/* NameVariableGlobal */ .chroma .vg { color: #ecbe7b }
/* NameVariableInstance */ .chroma .vi { color: #57c7ff }
/* NameVariableMagic */ .chroma .vm { color: #c9c9c9 }
/* Literal */ .chroma .l { color: #c9c9c9 }
/* LiteralDate */ .chroma .ld { color: #57c7ff }
/* LiteralString */ .chroma .s { color: #82cc6a }
/* LiteralStringAffix */ .chroma .sa { color: #82cc6a }
/* LiteralStringBacktick */ .chroma .sb { color: #57c7ff }
/* LiteralStringChar */ .chroma .sc { color: #57c7ff }
/* LiteralStringDelimiter */ .chroma .dl { color: #82cc6a }
/* LiteralStringDoc */ .chroma .sd { color: #82cc6a }
/* LiteralStringDouble */ .chroma .s2 { color: #82cc6a }
/* LiteralStringEscape */ .chroma .se { color: #56b6c2 }
/* LiteralStringHeredoc */ .chroma .sh { color: #56b6c2 }
/* LiteralStringInterpol */ .chroma .si { color: #82cc6a }
/* LiteralStringOther */ .chroma .sx { color: #82cc6a }
/* LiteralStringRegex */ .chroma .sr { color: #57c7ff }
/* LiteralStringSingle */ .chroma .s1 { color: #82cc6a }
/* LiteralStringSymbol */ .chroma .ss { color: #82cc6a }
/* LiteralNumber */ .chroma .m { color: #56b6c2 }
/* LiteralNumberBin */ .chroma .mb { color: #57c7ff }
/* LiteralNumberFloat */ .chroma .mf { color: #56b6c2 }
/* LiteralNumberHex */ .chroma .mh { color: #57c7ff }
/* LiteralNumberInteger */ .chroma .mi { color: #56b6c2 }
/* LiteralNumberIntegerLong */ .chroma .il { color: #56b6c2 }
/* LiteralNumberOct */ .chroma .mo { color: #57c7ff }
/* Operator */ .chroma .o { color: #bc74c4 }
/* OperatorWord */ .chroma .ow { color: #bc74c4 }
/* Punctuation */ .chroma .p { color: #56b6c2 }
/* Comment */ .chroma .c { color: #3e4460 }
/* CommentHashbang */ .chroma .ch { color: #3e4460; font-style: italic }
/* CommentMultiline */ .chroma .cm { color: #3e4460 }
/* CommentSingle */ .chroma .c1 { color: #3e4460 }
/* CommentSpecial */ .chroma .cs { color: #bc74c4; font-style: italic }
/* CommentPreproc */ .chroma .cp { color: #7fbaf5 }
/* CommentPreprocFile */ .chroma .cpf { color: #7fbaf5 }
/* Generic */ .chroma .g { color: #c9c9c9 }
/* GenericDeleted */ .chroma .gd { color: #cf5967 }
/* GenericEmph */ .chroma .ge { color: #c9c9c9; text-decoration: underline }
/* GenericError */ .chroma .gr { color: #cf5967; font-weight: bold }
/* GenericHeading */ .chroma .gh { color: #ecbe7b; font-weight: bold }
/* GenericInserted */ .chroma .gi { color: #ecbe7b }
/* GenericOutput */ .chroma .go { color: #43454f }
/* GenericPrompt */ .chroma .gp { color: #c9c9c9 }
/* GenericStrong */ .chroma .gs { color: #cf5967; font-weight: bold }
/* GenericSubheading */ .chroma .gu { color: #cf5967; font-style: italic }
/* GenericTraceback */ .chroma .gt { color: #c9c9c9 }
/* GenericUnderline */ .chroma .gl { color: #c9c9c9; text-decoration: underline }
/* TextWhitespace */ .chroma .w { color: #c9c9c9 }
body { color: #282c34; }
</style><body class="bg">
<pre tabindex="0" class="chroma"><code><span class="line"><span class="cl">Step 1: SET CURR = HEAD
</span></span><span class="line"><span class="cl">Step 2: DO
</span></span><span class="line"><span class="cl">    Step 3: PRINT CURR -&gt; DATA
</span></span><span class="line"><span class="cl">    Step 4: SET CURR = CURR -&gt; NEXT
</span></span><span class="line"><span class="cl">Step 5: WHILE (CURR != HEAD)
</span></span><span class="line"><span class="cl">Step 6: EXIT
</span></span></code></pre>
</body>
</html>
</div>
<ul>
<li><strong>Step 1:</strong> Initialize a pointer, CURR, and set it to the head of the circular
linked list.</li>
<li><strong>Step 2:</strong> Iterate through the list by following the next pointer of each
node until CURR is equal to the head of the list again.</li>
<li><strong>Step 3:</strong> Print the data of the current node.</li>
<li><strong>Step 4:</strong> Move the CURR pointer to the next node by following the next
pointer.</li>
<li><strong>Step 5:</strong> Repeat steps 2-4 until CURR is equal to the head again, indicating
that all nodes have been visited.</li>
<li><strong>Step 6:</strong> Exit</li>
</ul>
<h3><a name="iii-summarize-note-on-binary-tree" class="heading-anchor" href="#iii-summarize-note-on-binary-tree" rel="nofollow" aria-hidden="true"></a>iii) Summarize note on Binary Tree</h3>
<ul>
<li>A binary tree is a tree data structure.</li>
<li>Each node in a binary tree has at most two children.</li>
<li>The two children are referred to as the left child and right child.</li>
<li>The topmost node in a binary tree is called the root.</li>
<li>The left and right children can themselves be binary trees, creating a
hierarchical structure.</li>
<li>Binary trees are often used for searching and sorting algorithms.</li>
<li>They are also used in data compression and computer science.</li>
<li>They can be implemented using pointers in programming languages like C and
C++.</li>
</ul>
<h4><a name="types-of-binary-tree" class="heading-anchor" href="#types-of-binary-tree" rel="nofollow" aria-hidden="true"></a>Types of Binary Tree</h4>
<p><img loading="lazy" src="./Full-Binary-Tree.png" alt="Full Binary Tree" /></p>

<ul>
<li><strong>Full Binary Tree</strong> A full Binary tree is a special type of binary tree in
which every parent node/internal node has either two or no children.</li>
</ul>

<p><img loading="lazy" src="./Perfect-Binary-Tree.png" alt="Perfect Binary Tree" /></p>

<ul>
<li><strong>Perfect Binary Tree</strong> A perfect binary tree is a type of binary tree in
which every internal node has exactly two child nodes and all the leaf nodes
are at the same level.</li>
</ul>

<p><img loading="lazy" src="./Complete-Binary-Tree.png" alt="Complete Binary Tree" /></p>

<ul>
<li><strong>Complete Binary Tree</strong> A complete binary tree is just like a full binary
tree, but with two major differences</li>
</ul>

<p><img loading="lazy" src="Skewed-Binary-Tree.png" alt="Skewed Binary Tree" /></p>

<ul>
<li><strong>Skewed Binary Tree</strong> A skewed binary tree is a pathological/degenerate tree
in which the tree is either dominated by the left nodes or the right nodes.
Thus, there are two types of skewed binary tree: left-skewed binary tree and
right-skewed binary tree.</li>
</ul>

<p><img loading="lazy" src="./Balanced-Binary-Tree.png" alt="Balanced Binary Tree" /></p>

<ul>
<li><strong>Balanced Binary Tree</strong> It is a type of binary tree in which the difference
between the height of the left and the right subtree for each node is either 0
or 1.</li>
</ul>
<h2><a name="2-5-marks" class="heading-anchor" href="#2-5-marks" rel="nofollow" aria-hidden="true"></a>2. 5 Marks</h2><h3><a name="i-summarize-note-on-tranversal-of-binary-tree" class="heading-anchor" href="#i-summarize-note-on-tranversal-of-binary-tree" rel="nofollow" aria-hidden="true"></a>i) Summarize note on Tranversal of Binary Tree.</h3>
<p><img loading="lazy" src="Tranversal-of-Binary-Tree.png" alt="Tranversal of Binary Tree" /></p>

<p>Traversing a binary tree involves visiting each node in the tree in a specific
order. There are three common ways to traverse a binary tree:</p>

<ul>
<li><strong>In-order traversal</strong>: <em>Left Root Right</em> In this method, the left subtree of
a node is visited first, then the node itself, and finally the right subtree.
This method visits nodes in ascending order for a binary search tree.</li>
<li><strong>Pre-order traversal</strong>: <em>Root Left Right</em> In this method, the node is visited
first, then its left subtree, and finally the right subtree. This method is
used to create a copy of the tree.</li>
<li><strong>Post-order traversal</strong>: <em>Left Root Right</em> In this method, the left subtree
is visited first, then the right subtree, and finally the node itself. This
method is used to delete the tree.</li>
</ul>

<p>More Info <a href="https://www.youtube.com/watch?v=-b2lciNd2L4">https://www.youtube.com/watch?v=-b2lciNd2L4</a></p>
<h3><a name="ii-discover-short-note-on-dfs-along-with-its-advantage-and-disadvantage" class="heading-anchor" href="#ii-discover-short-note-on-dfs-along-with-its-advantage-and-disadvantage" rel="nofollow" aria-hidden="true"></a>ii) Discover short note on DFS along with its advantage and disadvantage.</h3>
<p>Depth-first search (DFS) is an algorithm for traversing or searching tree or
graph data structures.</p>

<ul>
<li>It starts at the root node (or some arbitrary node) and explores as far as
possible along each branch before backtracking.</li>
<li>The algorithm uses a stack data structure to keep track of the nodes to visit
next.</li>
<li>The algorithm starts by pushing the root node to the stack.</li>
<li>Then, it pops a node from the stack and visits it.</li>
<li>If the visited node has any unvisited children, it pushes them to the stack.</li>
<li>This process continues until the stack is empty or the desired node is found.</li>
<li>DFS visits the nodes as deep as possible before backtracking to visit the next
branch</li>
<li>DFS can be implemented in both recursive and non-recursive way</li>
<li>DFS is not guaranteed to find the shortest path to a node</li>
<li>DFS can be used to solve problems like finding the strongly connected
components in a directed graph, Topological sorting, solving puzzles like
mazes and Sudoku, and finding the path in a maze</li>
<li>DFS can also be used to detect cycle in a graph and solving problems like
finding the path between two nodes in a graph.</li>
</ul>
<h4><a name="advantage" class="heading-anchor" href="#advantage" rel="nofollow" aria-hidden="true"></a>Advantage</h4>
<ul>
<li>It is simple and easy to implement.</li>
<li>It can be used to solve many problems like finding the strongly connected
components in a directed graph, Topological sorting, solving puzzles like
mazes and Sudoku, and finding the path in a maze</li>
<li>It can be implemented in both recursive and non-recursive way</li>
</ul>
<h4><a name="disadvantage" class="heading-anchor" href="#disadvantage" rel="nofollow" aria-hidden="true"></a>Disadvantage</h4>
<ul>
<li>It requires a lot of memory to store the stack and the visited nodes.</li>
<li>It may take a long time to visit all the nodes in a large graph.</li>
<li>It is not guaranteed to find the shortest path to a node.</li>
<li>It is not suitable for graphs with large number of edges and vertices.</li>
<li>It is not efficient for finding the shortest path in a weighted graph.</li>
</ul>

<p>More example: <a href="https://www.youtube.com/watch?v=iaBEKo5sM7w">https://www.youtube.com/watch?v=iaBEKo5sM7w</a></p>
<h2><a name="3-5-marks" class="heading-anchor" href="#3-5-marks" rel="nofollow" aria-hidden="true"></a>3. 5 Marks</h2><h3><a name="i-explain-doubly-linked-list-write-an-algorithm-to-create-doubly-linked-list" class="heading-anchor" href="#i-explain-doubly-linked-list-write-an-algorithm-to-create-doubly-linked-list" rel="nofollow" aria-hidden="true"></a>i) Explain Doubly Linked List. Write an algorithm to create Doubly Linked list.</h3>
<p>A doubly linked list is a variation of the linked list data structure where each
node contains an additional pointer, typically called previous pointer, that
points to the previous node in the list. This allows for a more efficient
traversal of the list in both directions, as opposed to a singly linked list
where traversal is only possible in one direction.</p>

<ol>
<li>Start</li>
<li>Input the DATA to be inserted</li>
<li>Create a new node.</li>
<li>NewNode ‚Üí Data = DATA NewNode ‚ÜíLpoint =NULL</li>
<li>IF START IS NULL NewNode‚Üí Rpoint = NULL</li>
<li>Else NewNode ‚Üí Rpoint = START START‚ÜíLpoint = NewNode</li>
<li>START =NewNode</li>
<li>Stop</li>
</ol>
<h3><a name="ii-slove-the-following-graph" class="heading-anchor" href="#ii-slove-the-following-graph" rel="nofollow" aria-hidden="true"></a>ii) Slove the following graph.</h3>
<p><img loading="lazy" src="./Graph.png" alt="Graph" /></p>

		</main>
		
		<details id="table-of-content">
		   <summary>Table of Content</summary>
		<nav>
<ul>
<li><a href="#1-a-6-marks">1.A) 6 Marks</a>
<ul>
<li><a href="#i-illustrate-an-algorithm-to-count-number-of-nodes-in-singly-linked-list">
i) Illustrate an algorithm to count number of nodes in singly linked list.</a></li>
<li><a href="#ii-interpret-following-terminologies-i-node-ii-root-iii-leaf-node">
ii) Interpret following terminologies i) Node ii) Root iii) Leaf Node</a></li>
<li><a href="#iii-summarize-any-3-properties-of-b-tree">
iii) Summarize any 3 properties of B-Tree</a></li>
</ul></li>
<li><a href="#1-b-4-marks">
1.B) 4 Marks</a>
<ul>
<li><a href="#i-describe-linked-list-with-types">
i) Describe Linked List with types.</a></li>
<li><a href="#ii-illustrate-algorithm-to-display-data-from-circular-linked-list">
ii) Illustrate algorithm to display data from circular linked list.</a></li>
<li><a href="#iii-summarize-note-on-binary-tree">
iii) Summarize note on Binary Tree</a>
<ul>
<li><a href="#types-of-binary-tree">
Types of Binary Tree</a></li>
</ul></li>
</ul></li>
<li><a href="#2-5-marks">
2. 5 Marks</a>
<ul>
<li><a href="#i-summarize-note-on-tranversal-of-binary-tree">
i) Summarize note on Tranversal of Binary Tree.</a></li>
<li><a href="#ii-discover-short-note-on-dfs-along-with-its-advantage-and-disadvantage">
ii) Discover short note on DFS along with its advantage and disadvantage.</a>
<ul>
<li><a href="#advantage">
Advantage</a></li>
<li><a href="#disadvantage">
Disadvantage</a></li>
</ul></li>
</ul></li>
<li><a href="#3-5-marks">
3. 5 Marks</a>
<ul>
<li><a href="#i-explain-doubly-linked-list-write-an-algorithm-to-create-doubly-linked-list">
i) Explain Doubly Linked List. Write an algorithm to create Doubly Linked list.</a></li>
<li><a href="#ii-slove-the-following-graph">
ii) Slove the following graph.</a></li>
</ul></li>
</ul>
</nav>

		</details>
		
		<footer>
			<p style="text-align: center; font-size: small; margin-top: 5em;">
				<a href="https://anzenkodo.github.io/license">LICENSE</a>
			</p>
		</footer>
	</body>
	<script src="https://AnzenKodo.github.io/assets/js/mermaid.js"></script>
	<script id="MathJax-script" async src="https://AnzenKodo.github.io/assets/js/mathjax.js"></script>
	<script>
		/* document.getElementById('video').addEventListener('click', (ele) => {
			 if (ele.target.paused) {
				 ele.target.play();
			 } else {
				 ele.target.pause();
			 }
		}); */

		mermaid.initialize({
			theme: "neutral",
			themeVariables: {
			    lineColor: "#939598",
			}
		});

		MathJax = {
		  tex: {
			inlineMath: [['$', '$']],
			displayMath: [['$$', '$$']],
		  }
		};
	</script>
</html>
