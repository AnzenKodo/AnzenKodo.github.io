<!doctype html><title>PCPF QB - AK#Notes</title><link href=https://anzenkodo.github.io/notes/favicon.png rel=icon type=image/png><link href=https://anzenkodo.github.io/notes/manifest.json rel=manifest><link title="AK#Notes RSS Feed"href=https://anzenkodo.github.io/notes/feed.xml rel=alternate type=application/rss+xml><link title="AK#Notes JSON Feed"href=https://anzenkodo.github.io/notes/feed.json rel=alternate type=application/json><link title="AK#Notes Atom Feed"href=https://anzenkodo.github.io/notes/feed.atom rel=alternate type=application/atom+xml><link title="AK#Notes Sitemap"href=https://anzenkodo.github.io/notes/sitemap.xml rel=sitemap type=application/xml><link href="https://fontbit.io/css2?family=Radio+Canada:ital,wght@0,300;0,400;0,500;0,600;0,700;1,300;1,400;1,500;1,600;1,700&display=swap"rel=stylesheet><link href=https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.6.0/build/styles/tokyo-night-dark.min.css rel=stylesheet><link href=https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.5.1/katex.min.css rel=stylesheet><meta charset=utf-8><meta content="width=device-width,initial-scale=1"name=viewport><meta content=Axel name=author><meta content=#bd8bf2 name=theme-color><meta content="PCPF QB"property=og:title><meta content="https://ogsupa.com/api/v1?font_style=font-sans&title=PCPF%20QB&description=Module%201%201.%20What%20do%20you%20mean%20by%20Programming%20Paradigm.%20Explain%20with%20example%20the%20difference%20between%20declarative%20and%20imperative%20programming%20paradigm.%20%20%20%20%20Imperative%20Language%20Declarative%20Language%20%20%20%20%20Describes%20how%20to%20perform%20a%20computation%20Describes%20what%20computation%20should%20be%20performe&right_meta=AK%23Notes&background_color=%23bd8bf2"property=og:image><meta content="PCPF QB"name=twitter:title><meta content="Module 1 1. What do you mean by Programming Paradigm. Explain with example the difference between declarative and imperative programming paradigm.     Imperative Language Declarative Language     Describes how to perform a computation Describes what computation should be performe"name=twitter:description><meta content="https://ogsupa.com/api/v1?font_style=font-sans&title=PCPF%20QB&description=Module%201%201.%20What%20do%20you%20mean%20by%20Programming%20Paradigm.%20Explain%20with%20example%20the%20difference%20between%20declarative%20and%20imperative%20programming%20paradigm.%20%20%20%20%20Imperative%20Language%20Declarative%20Language%20%20%20%20%20Describes%20how%20to%20perform%20a%20computation%20Describes%20what%20computation%20should%20be%20performe&right_meta=AK%23Notes&background_color=%23bd8bf2"name=twitter:image><meta content=summary_large_image name=twitter:card><meta content="PCPF QB"itemprop=name><meta content="Module 1 1. What do you mean by Programming Paradigm. Explain with example the difference between declarative and imperative programming paradigm.     Imperative Language Declarative Language     Describes how to perform a computation Describes what computation should be performe"itemprop=description><meta content="https://ogsupa.com/api/v1?font_style=font-sans&title=PCPF%20QB&description=Module%201%201.%20What%20do%20you%20mean%20by%20Programming%20Paradigm.%20Explain%20with%20example%20the%20difference%20between%20declarative%20and%20imperative%20programming%20paradigm.%20%20%20%20%20Imperative%20Language%20Declarative%20Language%20%20%20%20%20Describes%20how%20to%20perform%20a%20computation%20Describes%20what%20computation%20should%20be%20performe&right_meta=AK%23Notes&background_color=%23bd8bf2"itemprop=image><meta content="Module 1 1. What do you mean by Programming Paradigm. Explain with example the difference between declarative and imperative programming paradigm.     Imperative Language Declarative Language     Describes how to perform a computation Describes what computation should be performe"name=description><script type=module>Array.from(document.querySelectorAll(".files *:has(.active)")).map(x => x.open = true);
      </script><style>*,::after,::before{-webkit-box-sizing:border-box;box-sizing:border-box;border:0 solid #e5e7eb}*{--tw-ring-inset:var(--tw-empty,/*!*/ /*!*/);--tw-ring-offset-width:0;--tw-ring-offset-color:#fff;--tw-ring-color:rgba(59,130,246,.5);--tw-ring-offset-shadow:0 0 #0000;--tw-ring-shadow:0 0 #0000;--tw-shadow:0 0 #0000}:root{-moz-tab-size:4;-o-tab-size:4;tab-size:4}:-moz-focusring{outline:1px dotted ButtonText}:-moz-ui-invalid{box-shadow:none}::moz-focus-inner{border:none;padding:0}::-webkit-inner-spin-button,::-webkit-outer-spin-button{height:auto}::-webkit-search-decoration{-webkit-appearance:none}::-webkit-file-upload-button{-webkit-appearance:button;font:inherit}[type='search']{-webkit-appearance:textfield;outline-offset:-2px}abbr[title]{-webkit-text-decoration:underline dotted;text-decoration:underline dotted}a{color:inherit;text-decoration:inherit}body{margin:0;font-family:inherit;line-height:inherit}html{-webkit-text-size-adjust:100%;font-family:ui-sans-serif,system-ui,-apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,"Helvetica Neue",Arial,"Noto Sans",sans-serif,"Apple Color Emoji","Segoe UI Emoji","Segoe UI Symbol","Noto Color Emoji";line-height:1.5}h1,h2,h3,h4{font-size:inherit;font-weight:inherit}input{padding:0;font:100%/inherit inherit;color:inherit;margin:0}img{border:solid;max-width:100%;height:auto}input::placeholder{opacity:1;color:#9ca3af}input::webkit-input-placeholder{opacity:1;color:#9ca3af}input::-moz-placeholder{opacity:1;color:#9ca3af}input:-ms-input-placeholder{opacity:1;color:#9ca3af}input::-ms-input-placeholder{opacity:1;color:#9ca3af}iframe,img{display:block;vertical-align:middle}code,pre{font:1em ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,"Liberation Mono","Courier New",monospace}figure,h1,h2,h3,h4,p,pre{margin:0}strong{font-weight:bolder}summary{display:list-item}table{text-indent:0;border:inherit;border-collapse:collapse}ol,ul{list-style:none;margin:0;padding:0}.bg-\$theme{background:var(--theme)}.bg-white{--tw-bg-opacity:1;background:rgba(255,255,255,var(--tw-bg-opacity))}.inline-block{display:inline-block}.grid{display:grid}.hidden{display:none}.font-bold{font-weight:700}.font-light{font-weight:300}.before\:font-normal::before{font-weight:400}.text-2xl{font-size:1.5rem;line-height:2rem}.text-xs{font-size:.75rem;line-height:1rem}.text-sm{font-size:.875rem;line-height:1.25rem}.text-4xl{font-size:2.25rem;line-height:2.5rem}.m-auto{margin:auto}.mx-auto{margin-left:auto;margin-right:auto}.my-5{margin-top:1.25rem;margin-bottom:1.25rem}.mx-3{margin-left:.75rem;margin-right:.75rem}.mb-8{margin-bottom:2rem}.ml-2{margin-left:.5rem}.before\:mr-before\:mr-2::before{margin-right:.5rem}.max-h-screen-sm{max-height:640px}.max-h-2em{max-height:2em}.max-w-screen-lg{max-width:1024px}.min-h-screen{min-height:100vh}.overflow-x-auto{overflow-x:auto}.p-0\.3em{padding:.3em}.p-5{padding:1.25rem}.p-2{padding:.5rem}.p-10{padding:2.5rem}.pt-2{padding-top:.5rem}.fixed{position:fixed}.absolute{position:absolute}.right-4{right:1rem}.top-5{top:1.25rem}.bottom-4{bottom:1rem}.text-center{text-align:center}.text-inherit{color:inherit}.italic{font-style:italic}.not-italic{font-style:normal}.before\:content-\/::before{content:"/"}.select-none{-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}.break-words{overflow-wrap:break-word}.hyphens-manual{-webkit-hyphens:manual;-ms-hyphens:manual;hyphens:manual}.gap-x-8{-webkit-column-gap:2rem;-moz-column-gap:2rem;grid-column-gap:2rem;column-gap:2rem}.grid-cols-\[13rem\2c 768px\]{grid-template-columns:13rem 768px}.col-start-2{grid-column-start:2}.transform{--tw-translate-x:0;--tw-translate-y:0;--tw-translate-z:0;--tw-rotate:0;--tw-rotate-x:0;--tw-rotate-y:0;--tw-rotate-z:0;--tw-skew-x:0;--tw-skew-y:0;--tw-scale-x:1;--tw-scale-y:1;--tw-scale-z:1;-webkit-transform:translateX(var(--tw-translate-x)) translateY(var(--tw-translate-y)) translateZ(var(--tw-translate-z)) rotate(var(--tw-rotate)) rotateX(var(--tw-rotate-x)) rotateY(var(--tw-rotate-y)) rotateZ(var(--tw-rotate-z)) skewX(var(--tw-skew-x)) skewY(var(--tw-skew-y)) scaleX(var(--tw-scale-x)) scaleY(var(--tw-scale-y)) scaleZ(var(--tw-scale-z));-ms-transform:translateX(var(--tw-translate-x)) translateY(var(--tw-translate-y)) translateZ(var(--tw-translate-z)) rotate(var(--tw-rotate)) rotateX(var(--tw-rotate-x)) rotateY(var(--tw-rotate-y)) rotateZ(var(--tw-rotate-z)) skewX(var(--tw-skew-x)) skewY(var(--tw-skew-y)) scaleX(var(--tw-scale-x)) scaleY(var(--tw-scale-y)) scaleZ(var(--tw-scale-z));transform:translateX(var(--tw-translate-x)) translateY(var(--tw-translate-y)) translateZ(var(--tw-translate-z)) rotate(var(--tw-rotate)) rotateX(var(--tw-rotate-x)) rotateY(var(--tw-rotate-y)) rotateZ(var(--tw-rotate-z)) skewX(var(--tw-skew-x)) skewY(var(--tw-skew-y)) scaleX(var(--tw-scale-x)) scaleY(var(--tw-scale-y)) scaleZ(var(--tw-scale-z))}.focus\:translate-y-0:focus{--tw-translate-y:0}.-translate-y-20\/10{--tw-translate-y:-200%}@media (prefers-color-scheme:dark){.\@dark\:bg-black{--tw-bg-opacity:1;background:rgba(0,0,0,var(--tw-bg-opacity))}}</style><meta content=website property=og:type><meta content=AK#Notes property=og:site_name><meta content=en property=og:locale><meta content=https://anzenkodo.github.io/notes/Collage/Sem3/PCPF-QB.html property=og:url><meta content=summary name=twitter:card><meta content=@AnzenKodo name=twitter:site><meta content="Lume v1.13.0"name=generator><body><style>:root{--theme:#583fcb;color-scheme:dark light;accent-color:rgba(var(--theme), 1)}::selection{--tw-bg-opacity:1;background-color:rgba(59, 130, 246, var(--tw-bg-opacity));--tw-text-opacity:1;color:rgba(255, 255, 255, var(--tw-text-opacity))}body{font-family:'Radio Canada', sans-serif}a{color:var(--theme)}a:hover,a:focus{-webkit-text-decoration-line:underline;text-decoration-line:underline}a:active{background-color:var(--theme);color:inherit}.footnotes{margin-top:0.75rem}.footnotes li p{margin-bottom:0px}@media (prefers-color-scheme: dark){:root{--theme:#bd8bf2}}.files summary{cursor:pointer}.files li{line-height:1.25;margin-top:0.5rem}.files details{margin-top:0.5rem}.files details details{margin-left:0.75rem}.files details li{margin-left:1rem}.files .active{font-weight:700}.files .not-active{font-weight:400}.toc ol{list-style-type:decimal;counter-reset:item}.toc li{list-style-position:inside;margin-left:0.75rem}.toc ol li::before{content:counters(item, &quot;.&quot;) &quot;counter-increment:item}.content p,.content pre,.content ul,.content ol,.content blockqoute,.content dl,.content table{margin-bottom:1rem}.content h1,.content h2,.content h3,.content h4,.content h5,.content h6{font-weight:700;margin-top:2.5rem;margin-bottom:0.5rem}.content h1:hover::after,.content h2:hover::after,.content h3:hover::after,.content h4:hover::after,.content h5:hover::after,.content h6:hover::after{margin-left:0.25rem;color:var(--theme);content:"#"}.content h1 a,.content h2 a,.content h3 a,.content h4 a,.content h5 a,.content h6 a{color:inherit;text-decoration:none}.content{line-height:1.625;letter-spacing:0.05em;word-spacing:.3em}.content h1{font-size:1.875rem;line-height:2.25rem}.content h2{font-size:1.5rem;line-height:2rem}.content h3{font-size:1.25rem;line-height:1.75rem}.content h4{font-size:1.125rem;line-height:1.75rem}.content h5{font-size:1rem;line-height:1.5rem}.content h6{font-size:0.875rem;line-height:1.25rem}.content ul li,ol li{margin-left:1.25rem;margin-bottom:0.25rem}.content ul li{list-style-type:disc}.content ul li ul li{list-style-type:circle}.content ul li ul li ul li{list-style-position:outside;list-style-type:square}.content ol li{list-style-type:decimal}.content blockquote{border-left-width:5px;margin-left:2.5rem;margin-right:2.5rem;margin-top:0.75rem;margin-bottom:0.25rem;padding-top:1rem;padding-bottom:0.25rem;padding-left:1rem;padding-right:1rem}.content img{border-style:none;display:inline}.content figcaption{margin-top:0.5rem;text-align:center;font-style:italic}][disabled]{cursor:default}.content input ~ label{margin-left:0.75rem}.content .task-list-item{list-style-type:none}.content table{display:block;overflow:auto}.content th,.content td{border-width:1px;padding-left:0.75rem;padding-right:0.75rem}.content table caption{font-style:italic}.content pre{overflow-x:auto;word-spacing:0;line-height:0;padding:1rem;background:#1a1b26}.content .katex{display:inline-flex;max-width:100%;overflow:auto;padding-bottom:.5em}.content iframe{width:100%;height:61vmin}@media (max-width: 1023.9px){.page{display:block}.menu{display:inline}.menu-items{display:none}.menu input{-webkit-appearance:none;-moz-appearance:none;appearance:none}.menu input::before{font-size:2.25rem;line-height:2.5rem;line-height:1;padding-left:0.075rem;content:"☰"}.menu input:checked::before{padding-left:0.25rem;content:"Χ"}.menu:has(input:checked) + .menu-items{display:block}main{margin-top:1.25rem}}</style><a class="p-0.3em absolute bg-$theme text-inherit transform -translate-y-20/10 focus:translate-y-0"href=#main>Skip to content</a><div class="p-5 mx-auto max-w-screen-lg grid grid-cols-[13rem,768px] gap-x-8 page"><aside><p class="font-bold text-2xl m-auto"><a href=https://AnzenKodo.github.io/>AK</a>#Notes<div class="absolute right-4 top-5 hidden menu"><input type=checkbox><label for="Menu button"></label></div><div class=menu-items><p class=feed>Feeds: <a href=https://anzenkodo.github.io/notes/feed.xml>RSS</a> <a href=https://anzenkodo.github.io/notes/feed.atom>Atom</a> <a href=https://anzenkodo.github.io/notes/feed.json>JSON</a><nav class="my-5 files"><ul><li class=not-active><a href=https://anzenkodo.github.io/notes/>Home</a><details><summary class=not-active>Books</summary><li class=not-active><a href=https://anzenkodo.github.io/notes/Books/12-Rules-of-Life>12 Rules of Life</a><li class=not-active><a href=https://anzenkodo.github.io/notes/Books/Algorithms-to-Live-by>Algorithms to Live by</a><li class=not-active><a href=https://anzenkodo.github.io/notes/Books/An-Open-Lette-To-Open-Minded-Progressives>An Open Lette To Open Minded Progressives</a><li class=not-active><a href=https://anzenkodo.github.io/notes/Books/Anything-You-Want>Anything You Want</a><li class=not-active><a href=https://anzenkodo.github.io/notes/Books/Elon-Musk-Blog-Series>Elon Musk Blog Series</a><li class=not-active><a href=https://anzenkodo.github.io/notes/Books/Enlightenment-Now>Enlightenment Now</a><li class=not-active><a href=https://anzenkodo.github.io/notes/Books/Give-and-Take>Give and Take</a><li class=not-active><a href=https://anzenkodo.github.io/notes/Books/Hell-Yeah-or-No>Hell Yeah or No</a><li class=not-active><a href=https://anzenkodo.github.io/notes/Books/Keep-Going>Keep Going</a><li class=not-active><a href=https://anzenkodo.github.io/notes/Books/Newspaper-Blackout>Newspaper Blackout</a><li class=not-active><a href=https://anzenkodo.github.io/notes/Books/Originals>Originals</a><li class=not-active><a href=https://anzenkodo.github.io/notes/Books/Personal-Values>Personal Values</a><li class=not-active><a href=https://anzenkodo.github.io/notes/Books/Range>Range</a><li class=not-active><a href=https://anzenkodo.github.io/notes/Books/Self-Discipline>Self Discipline</a><li class=not-active><a href=https://anzenkodo.github.io/notes/Books/Show-your-work>Show your work</a><li class=not-active><a href=https://anzenkodo.github.io/notes/Books/Steal-Like-an-Artist>Steal Like an Artist</a><li class=not-active><a href=https://anzenkodo.github.io/notes/Books/Your-First-Year-in-Code>Your First Year in Code</a><li class=not-active><a href=https://anzenkodo.github.io/notes/Books/Your-Music-and-People>Your Music and People</a></details><details><summary class=not-active>Collage</summary><details><summary class=not-active>Notes</summary><li class=not-active><a href=https://anzenkodo.github.io/notes/Collage/Notes/DSA>DSA</a><li class=not-active><a href=https://anzenkodo.github.io/notes/Collage/Notes/PCOM>PCOM</a><li class=not-active><a href=https://anzenkodo.github.io/notes/Collage/Notes/PCPF>PCPF</a></details><details><summary class=not-active>Sem1</summary><li class=not-active><a href=https://anzenkodo.github.io/notes/Collage/Sem1/EMIII>EMIII</a></details><details><summary class=not-active>Sem3</summary><li class=not-active><a href=https://anzenkodo.github.io/notes/Collage/Sem3/DBMS-Notes>DBMS Notes</a><li class=not-active><a href=https://anzenkodo.github.io/notes/Collage/Sem3/DSA-2019-QP>DSA 2019 QP</a><li class=active><a href=https://anzenkodo.github.io/notes/Collage/Sem3/PCPF-QB>PCPF QB</a></li><details><summary class=not-active>Notes</summary><li class=not-active><a href=https://anzenkodo.github.io/notes/Collage/Sem3/Notes/DSA>DSA</a><li class=not-active><a href=https://anzenkodo.github.io/notes/Collage/Sem3/Notes/PCOM>PCOM</a><li class=not-active><a href=https://anzenkodo.github.io/notes/Collage/Sem3/Notes/PCPF>PCPF</a></details><details><summary class=not-active>UT1</summary><li class=not-active><a href=https://anzenkodo.github.io/notes/Collage/Sem3/UT1/DSA>DSA</a></details><details><summary class=not-active>UT2</summary><li class=not-active><a href=https://anzenkodo.github.io/notes/Collage/Sem3/UT2/DBMS>DBMS</a><li class=not-active><a href=https://anzenkodo.github.io/notes/Collage/Sem3/UT2/DSA>DSA</a><li class=not-active><a href=https://anzenkodo.github.io/notes/Collage/Sem3/UT2/PCPF>PCPF</a></details></details><details><summary class=not-active>Sem4</summary><details><summary class=not-active>EMIV</summary><li class=not-active><a href=https://anzenkodo.github.io/notes/Collage/Sem4/EMIV/Syllabus>Syllabus</a></li><details><summary class=not-active>.ipynb_checkpoints</summary></details></details></details><details><summary class=not-active>UT1</summary><li class=not-active><a href=https://anzenkodo.github.io/notes/Collage/UT1/DSA>DSA</a></details><details><summary class=not-active>UT2</summary><li class=not-active><a href=https://anzenkodo.github.io/notes/Collage/UT2/DBMS>DBMS</a><li class=not-active><a href=https://anzenkodo.github.io/notes/Collage/UT2/DSA>DSA</a><li class=not-active><a href=https://anzenkodo.github.io/notes/Collage/UT2/PCPF>PCPF</a></details></details><details><summary class=not-active>Maths</summary><li class=not-active><a href=https://anzenkodo.github.io/notes/Maths/Definition>Definition</a></li><details><summary class=not-active>Discrete Mathematics</summary><li class=not-active><a href=https://anzenkodo.github.io/notes/Maths/Discrete-Mathematics/Set>Set</a><li class=not-active><a href=https://anzenkodo.github.io/notes/Maths/Discrete-Mathematics/sets>sets</a></details><details><summary class=not-active><a href=https://anzenkodo.github.io/notes/Maths/Inverse-Laplace-Transform>Inverse Laplace Transform</a></summary><li class=not-active><a href=https://anzenkodo.github.io/notes/Maths/Inverse-Laplace-Transform/First-Shifting-Theorem>First Shifting Theorem</a></details><details><summary class=not-active>Laplace Transform</summary><li class=not-active><a href=https://anzenkodo.github.io/notes/Maths/Laplace-Transform/Formulas>Formulas</a><li class=not-active><a href=https://anzenkodo.github.io/notes/Maths/Laplace-Transform/Introduction>Introduction</a><li class=not-active><a href=https://anzenkodo.github.io/notes/Maths/Laplace-Transform/Sums>Sums</a></details><li class=not-active><a href=https://anzenkodo.github.io/notes/Maths/Statistics>Statistics</a><li class=not-active><a href=https://anzenkodo.github.io/notes/Maths/Statistics/Rank-Correlation>Rank Correlation</a><li class=not-active><a href=https://anzenkodo.github.io/notes/Maths/Statistics/Regression>Regression</a></details><details><summary class=not-active>Programming</summary><li class=not-active><a href=https://anzenkodo.github.io/notes/Programming/Computer-Paradigms>Computer Paradigms</a></li><details><summary class=not-active>android</summary><li class=not-active><a href=https://anzenkodo.github.io/notes/Programming/android/Final>Final</a><li class=not-active><a href=https://anzenkodo.github.io/notes/Programming/android/Notes>Notes</a><li class=not-active><a href=https://anzenkodo.github.io/notes/Programming/android/Pratical-S6>Pratical S6</a><li class=not-active><a href=https://anzenkodo.github.io/notes/Programming/android/UT2-6S>UT2 6S</a><li class=not-active><a href=https://anzenkodo.github.io/notes/Programming/android/Viva-6S-sort>Viva 6S sort</a><li class=not-active><a href=https://anzenkodo.github.io/notes/Programming/android/Viva-6S>Viva 6S</a></details><details><summary class=not-active>data structure</summary><li class=not-active><a href=https://anzenkodo.github.io/notes/Programming/data-structure/ii>ii</a></li><details><summary class=not-active><a href=https://anzenkodo.github.io/notes/Programming/data-structure/linked-list>linked list</a></summary><li class=not-active><a href=https://anzenkodo.github.io/notes/Programming/data-structure/linked-list/circular-linked-list>circular linked list</a><li class=not-active><a href=https://anzenkodo.github.io/notes/Programming/data-structure/linked-list/doubly-linked-list>doubly linked list</a><li class=not-active><a href=https://anzenkodo.github.io/notes/Programming/data-structure/linked-list/singly-linked-list>singly linked list</a></details><details><summary class=not-active>tree</summary><li class=not-active><a href=https://anzenkodo.github.io/notes/Programming/data-structure/tree/decision-tree>decision tree</a><li class=not-active><a href=https://anzenkodo.github.io/notes/Programming/data-structure/tree/threaded-binary-tree>threaded binary tree</a></details></details><details><summary class=not-active>database</summary><li class=not-active><a href=https://anzenkodo.github.io/notes/Programming/database/keys>keys</a><li class=not-active><a href=https://anzenkodo.github.io/notes/Programming/database/question-bank>question bank</a><li class=not-active><a href=https://anzenkodo.github.io/notes/Programming/database/Entity-Relationship-Model>Entity Relationship Model</a></details><li class=not-active><a href=https://anzenkodo.github.io/notes/Programming/database/er-diagram>er diagram</a></details><li class=not-active><a href=https://anzenkodo.github.io/notes/Programming/database/SQL>SQL</a></li><details><summary class=not-active>Languages</summary><li class=not-active><a href=https://anzenkodo.github.io/notes/Programming/Languages/Bash>Bash</a><li class=not-active><a href=https://anzenkodo.github.io/notes/Programming/Languages/C>C</a><li class=not-active><a href=https://anzenkodo.github.io/notes/Programming/Languages/CSS>CSS</a><li class=not-active><a href=https://anzenkodo.github.io/notes/Programming/Languages/Java>Java</a></li><details><summary class=not-active>JavaScript</summary><li class=not-active><a href=https://anzenkodo.github.io/notes/Programming/Languages/JavaScript/Browser>Browser</a><li class=not-active><a href=https://anzenkodo.github.io/notes/Programming/Languages/JavaScript/JS>JS</a><li class=not-active><a href=https://anzenkodo.github.io/notes/Programming/Languages/JavaScript/NodeJS>NodeJS</a><li class=not-active><a href=https://anzenkodo.github.io/notes/Programming/Languages/JavaScript/React>React</a></details><details><summary class=not-active>PHP</summary><li class=not-active><a href=https://anzenkodo.github.io/notes/Programming/Languages/PHP/Final>Final</a><li class=not-active><a href=https://anzenkodo.github.io/notes/Programming/Languages/PHP/Notes>Notes</a><li class=not-active><a href="https://anzenkodo.github.io/notes/Programming/Languages/PHP/Pratical Sem6">Pratical Sem6</a><li class=not-active><a href=https://anzenkodo.github.io/notes/Programming/Languages/PHP/Sample-Paper-6S>Sample Paper 6S</a><li class=not-active><a href=https://anzenkodo.github.io/notes/Programming/Languages/PHP/UT1-6S>UT1 6S</a><li class=not-active><a href=https://anzenkodo.github.io/notes/Programming/Languages/PHP/UT2-6S>UT2 6S</a></details><details><summary class=not-active>Python</summary><li class=not-active><a href=https://anzenkodo.github.io/notes/Programming/Languages/Python/Finals>Finals</a><li class=not-active><a href=https://anzenkodo.github.io/notes/Programming/Languages/Python/Notes>Notes</a><li class=not-active><a href=https://anzenkodo.github.io/notes/Programming/Languages/Python/Practical-S6>Practical S6</a><li class=not-active><a href=https://anzenkodo.github.io/notes/Programming/Languages/Python/Sample-Paper-6S>Sample Paper 6S</a><li class=not-active><a href=https://anzenkodo.github.io/notes/Programming/Languages/Python/UT1-6S>UT1 6S</a><li class=not-active><a href=https://anzenkodo.github.io/notes/Programming/Languages/Python/UT2-6S>UT2 6S</a></details></details><details><summary class=not-active>Study</summary><li class=not-active><a href=https://anzenkodo.github.io/notes/Study/Grammmar>Grammmar</a><li class=not-active><a href=https://anzenkodo.github.io/notes/Study/MGT>MGT</a></li><details><summary class=not-active>Communication</summary><li class=not-active><a href=https://anzenkodo.github.io/notes/Study/Communication/Amplitude-Modulation>Amplitude Modulation</a><li class=not-active><a href=https://anzenkodo.github.io/notes/Study/Communication/Communication>Communication</a></li><details><summary class=not-active>Basic</summary><li class=not-active><a href=https://anzenkodo.github.io/notes/Study/Communication/Basic/Basic>Basic</a></details><li class=not-active><a href=https://anzenkodo.github.io/notes/Study/Communication/Classification>Classification</a></details><li class=not-active><a href=https://anzenkodo.github.io/notes/Study/Communication/Modulation>Modulation</a></details><li class=not-active><a href=https://anzenkodo.github.io/notes/Study/Communication/Need-of-Modulation>Need of Modulation</a></ul></nav></div><nav class="fixed bottom-4 right-4 text-xs bg-white @dark:bg-black p-2 max-h-screen-sm overflow-x-auto toc"><details><summary class=text-sm>Table of Content</summary><ol class=pt-2><ol><li><a href=#module-1>Module 1</a><ol><li><a href=#1.-what-do-you-mean-by-programming-paradigm.-explain-with-example-the-difference-between-declarative-and-imperative-programming-paradigm.>1. What do you mean by Programming Paradigm. Explain with example the difference between declarative and imperative programming paradigm.</a><li><a href=#3.-explain-type-system-and-type-checking.>3. Explain type system and type checking.</a><li><a href=#4.-explain-different-storage-allocation-mechanisms.>4. Explain different storage allocation mechanisms.</a><ol><li><a href=#static-storage-allocation>Static Storage Allocation</a><li><a href=#stack-based-storage-allocation>Stack Based Storage Allocation</a><li><a href=#heap-allocation>Heap Allocation</a></ol><li><a href=#5.-static-scoping-vs.-dynamic-scoping>5. Static Scoping vs. Dynamic Scoping</a><li><a href=#6.-discuss-call-by-value-vs.-call-by-reference.>6. Discuss Call by value vs. Call by reference.</a><ol><li><a href=#call-by-value>Call by value</a><li><a href=#call-by-reference>Call by reference</a><li><a href=#difference-between-call-by-value-and-call-by-reference-in-c>Difference Between Call by Value and Call by Reference in C</a></ol><li><a href=#7.-types-of-binding-in-programming-languages>7. Types of binding in Programming Languages</a><ol><li><a href=#static-binding>Static binding</a><li><a href=#dynamic-binding>Dynamic binding</a></ol><li><a href=#8.-write-a-note-on-naming-and-scoping-rules-for-scripting-languages.>8. Write a note on Naming and Scoping rules for scripting languages.</a><ol><li><a href=#naming>Naming</a><li><a href=#scoping>Scoping</a></ol><li><a href=#9.-describe-different-parameter-passing-modes.>9. Describe different parameter passing modes.</a><li><a href=#10.-compare-heap-based-and-stack-based-principal-storage-allocation-mechanism.>10. Compare heap based and stack-based principal storage allocation mechanism.</a><li><a href=#11.-discuss-scope-with-reference-to-binding-in-program.-also-compare-static-and-dynamic-scoping.>11. Discuss Scope with reference to binding in program. Also compare static and dynamic scoping.</a><li><a href=#12.-justify-the-following-statement%2C-%E2%80%9Cno-single-factor-determines-whether-a-programming-language-is-good.%E2%80%9D>12. Justify the following statement, “No single factor determines whether a programming language is good.”</a></ol><li><a href=#module-2>Module 2</a><ol><li><a href=#1.-explain-type-and-type-classes-in-haskell.>1. Explain Type and Type classes in Haskell.</a><li><a href=#2.-what-is-composite-data-type%3F-explain-different-composite-data-types-in-haskell.>2. What is composite data type? Explain different composite data types in Haskell.</a><li><a href=#4.-lambda-calculus>4. Lambda Calculus</a><li><a href=#5.-what-is-pattern-matching-in-haskell.-explain-with-an-example.>5. What is pattern matching in Haskell. Explain with an example.</a><li><a href=#6.-higher-order-function>6. Higher order function</a><li><a href=#7.-what-mathematical-formalism-underlies-functional-programming%3F>7. What mathematical formalism underlies functional programming?</a><li><a href=#8.-explain-concept-of-currying-in-haskell-with-an-example.>8. Explain concept of currying in haskell with an example.</a><li><a href=#9.-explain-features-of-functional-programming-languages.>9. Explain features of functional programming languages.</a><ol><li><a href=#immutable-data>Immutable Data</a><li><a href=#referential-transparency>Referential transparency</a><li><a href=#modularity>Modularity</a><li><a href=#maintainability>Maintainability</a><li><a href=#closure>Closure</a></ol><li><a href=#higher-order-functions>Higher-order functions</a><li><a href=#pure-function>Pure function</a><ol><li><a href=#impure-functions>Impure functions</a></ol><li><a href=#10.-what-is-the-difference-between-normal-order-and-applicative-order-evaluation%3F-what-is-lazy-evaluation%3F>10. What is the difference between normal-order and applicative-order evaluation? What is lazy evaluation?</a><li><a href=#11.-the-haskell-function-head-defined-in-prelude%2C-returns-the-first-element-of-a-list-and-throws-an-exception-when-we-try-to-apply-it-on-an-empty-list.-define-two-variants-of-this-function-(you-can-use-different-names)-that-work-exactly-like-head-function-except-in-the-case-of-an-empty-list-input-they-will-show-%5B%5D-as-output-instead-of-throwing-an-exception.-you-must-use-the-following-constructs-in-haskell-for-defining-the-functions.>11. The haskell function head defined in prelude, returns the first element of a list and throws an exception when we try to apply it on an empty list. Define two variants of this function (you can use different names) that work exactly like head function except in the case of an empty list input they will show [] as output instead of throwing an exception. You must use the following constructs in Haskell for defining the functions.</a><li><a href=#12.-define-haskell-function-that-inputs-one-operator-%2B%2C-%2C*%2C%5E-and-two-operands-which-may-be-int%2C-integer%2C-float-or-double.-the-function-will-perform-the-operation-and-computes-the-result.-clearly-mention-the-type-signature-for-the-function.>12. Define Haskell function that inputs one operator +,-,*,^ and two operands which may be Int, Integer, Float or Double. The function will perform the operation and computes the result. Clearly mention the type signature for the function.</a><li><a href=#13.-define-a-haskell-function-named-%E2%80%9Caddus%E2%80%9D-that-adds-2-input-numbers.>13. Define a haskell function named “addUs” that adds 2 input numbers.</a></ol><li><a href=#module-3>Module 3</a><ol><li><a href=#2.-write-following-english-statements-in-prolog.-mention-which-are-facts-and-rules.>2. Write following English statements in Prolog. Mention which are facts and rules.</a><li><a href=#4.-explain-what-are-facts%2C-rules%2C-and-queries-in-logic-programming-with-example.>4. Explain what are facts, rules, and queries in logic programming with example.</a><li><a href=#5.-describe-the-difference-between-forward-chaining-and-backward-chaining.-which-is-used-in-prolog-by-default%3F>5. Describe the difference between forward chaining and backward chaining. Which is used in Prolog by default?</a><li><a href=#6.-list-operations-in-prolog>6. List operations in Prolog</a><li><a href=#7.-explain-prolog-database-manipulation-commands-with-an-example.>7. Explain prolog database manipulation commands with an example.</a><ol><li><a href=#static-database-manipulation.>Static Database Manipulation.</a><li><a href=#dynamic-database-manipulation>Dynamic Database Manipulation</a></ol><li><a href=#8.-why-do-we-use-%E2%80%9Cis%E2%80%9D-instead-of-%E2%80%9C%3D%E2%80%9D-in-prolog%3F>8. Why do we use “is” instead of “=” in prolog?</a><li><a href=#9.-write-a-prolog-code-to-find-if-a-list-is-sorted-or-not.>9. Write a prolog code to find if a list is sorted or not.</a><li><a href=#10.-briefly-describe-the-process-of-resolution-and-unification-in-logic-programming-with-example.>10. Briefly describe the process of resolution and unification in logic programming with example.</a><li><a href=#11.-explain-how-prolog-differs-from-imperative-languages-in-its-handling-of-arithmetic.>11. Explain how Prolog differs from imperative languages in its handling of arithmetic.</a><li><a href=#12.-explain-what-are-facts%2C-rules%2C-and-queries-in-logic-programming-with-example.>12. Explain what are facts, rules, and queries in logic programming with example.</a></ol></ol></ol></details></nav></aside><main class="min-h-screen break-words"id=main><div class=mb-8><h1 class="text-4xl font-bold">PCPF QB</h1><ul class="font-light text-sm italic"><li class=inline-block><span class="not-italic select-none">Date: </span><time datetime="Tue Mar 07 2023 07:32:28 GMT+0000 (Coordinated Universal Time)">7-3-2023</time><li class="inline-block before:content-/ ml-2 before:mr-before:mr-2 before:font-normal"><span class="not-italic select-none">Reading Time: </span>37min</ul></div><div class="hyphens-manual content"><div><h2 id=module-1 tabindex=-1><a class=header-anchor href=#module-1>Module 1</a></h2><h3 id=1.-what-do-you-mean-by-programming-paradigm.-explain-with-example-the-difference-between-declarative-and-imperative-programming-paradigm. tabindex=-1><a class=header-anchor href=#1.-what-do-you-mean-by-programming-paradigm.-explain-with-example-the-difference-between-declarative-and-imperative-programming-paradigm.>1. What do you mean by Programming Paradigm. Explain with example the difference between declarative and imperative programming paradigm.</a></h3><iframe allow="accelerometer; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share"title="YouTube video player"allowfullscreen frameborder=0 src=https://www.youtube-nocookie.com/embed/z6GbGzDst18></iframe><table><thead><tr><th>Imperative Language<th>Declarative Language<tbody><tr><td>Describes how to perform a computation<td>Describes what computation should be performed<tr><td>Uses statements and instructions to change the state of the program<td>Uses expressions and declarations to describe the<tr><td>Focuses on control flow and the order of<td>Focuses on the problem to be solved, not the solution<tr><td>Examples: C, C++, Java, Python<td>Examples: SQL, Prolog, Haskell, Lisp<tr><td>Code is written in a step-by-step manner<td>Code is written in a more abstract and logical way<tr><td>Emphasizes on the process and the sequence of instructions<td>Emphasizes on the final outcome and the results<tr><td>Uses variables and mutable data structures<td>Uses constants and immutable data structures<tr><td>Programs are written with explicit control flow<td>Programs are written with implicit control flow<tr><td>Programs are written with explicit memory management<td>Programs are written with implicit memory management<tr><td>Programs are written with explicit error handling<td>Programs are written with implicit error handling<tr><td>Programs are written with explicit state management<td>Programs are written with implicit state management</table><p>Declarative programming focuses on describing the desired outcome of a program, rather than specifying how to achieve it. In this paradigm, the programmer declares what the program should do and the underlying system is responsible for executing the task. Examples of declarative programming languages are SQL, HTML, and XSLT.<p>Imperative programming, on the other hand, focuses on specifying how the task should be executed. In this paradigm, the programmer writes code that explicitly describes the steps to be taken to achieve a desired outcome. Examples of imperative programming languages are C, Java, and Python.<p>In summary, declarative programming focuses on what to do, while imperative programming focuses on how to do it.<h3 id=3.-explain-type-system-and-type-checking. tabindex=-1><a class=header-anchor href=#3.-explain-type-system-and-type-checking.>3. Explain type system and type checking.</a></h3><p>A type system is a formal set of rules in a programming language that defines the types of data that can be stored and processed, as well as the operations that can be performed on these data types. A type system helps ensure that the data used in a program is well-defined and consistent, and it can help prevent type-related errors from occurring.<p>Type checking is the process of verifying that a program follows the rules defined by the type system. Type checking can occur at various stages of the software development process, including compile-time, run-time, or both. During type checking, the system checks that each value in the program has a well-defined type, and that each operation performed on a value is valid for that type.<p>In C, common types include int (integer), char (character), float (floating point number), and double (double precision floating point number).<p>In Haskell, common types include Int (integer), Float (floating point number), Char (character), and [a] (list of values of type a).<h3 id=4.-explain-different-storage-allocation-mechanisms. tabindex=-1><a class=header-anchor href=#4.-explain-different-storage-allocation-mechanisms.>4. Explain different storage allocation mechanisms.</a></h3><ul><li>Storage management is the process of managing the allocation, deallocation, and use of memory in a computer system.<li>The goal of storage management is to ensure that the system has enough memory available for its needs, while minimizing the amount of wasted memory.<li>Programs require memory to store data such as variables, arrays, and objects.<li>Memory is allocated to the program in chunks called blocks.<li>Storage management is responsible for allocating these blocks of memory to the program.<li>It also keeps track of which blocks are in use and which are free.<li>It deallocates blocks that are no longer needed.</ul><figure data-type=image><img alt="Stoage Management Diagram"decoding=async loading=lazy src=./memory.png></figure><table><thead><tr><th>Mechanism<th>Allocation<th>Deallocation<th>Lifetime<th>Speed<th>Responsibility<th>Usage<tbody><tr><td>Stack allocation<td>LIFO<td>Automatically managed by the system<td>Function call<td>Fast<td>System<td>Function call frames and local variables<tr><td>Heap allocation<td>Dynamic, at runtime<td>Programmer-managed<td>Persistent<td>Slow<td>Programmer<td>Objects and data structures with a longer lifetime<tr><td>Static allocation<td>At compile time<td>Persistent for the entire program<td>Entire program<td>Fast<td>None<td>Global variables and constants</table><h4 id=static-storage-allocation tabindex=-1><a class=header-anchor href=#static-storage-allocation>Static Storage Allocation</a></h4><ul><li>Static storage allocation is a method of allocating memory for a program during the compilation process, before the program is executed.<li>This method is also known as “compile-time allocation” or “static memory allocation.”<li>The memory is allocated in a fixed size and the size remains constant throughout the execution of the program.<li>Pros: <ul><li>Simple to implement and understand.<li>Memory allocation is done at compile time, so it is known in advance how much memory will be used by the program.<li>No need for memory allocation and deallocation during runtime, so it can be more efficient.</ul><li>Cons: <ul><li>The amount of memory allocated cannot be changed during runtime.<li>If the program requires more memory than what was allocated at compile time, it can lead to memory overflow errors.<li>If the program uses less memory than what was allocated at compile time, it can lead to wasted memory.</ul></ul><h4 id=stack-based-storage-allocation tabindex=-1><a class=header-anchor href=#stack-based-storage-allocation>Stack Based Storage Allocation</a></h4><ul><li>Stack-based storage allocation is a method of allocating memory for a program where memory is allocated and deallocated in a last-in, first-out (LIFO) order.<li>The stack is a data structure that stores data in a linear manner, with the most recent item being added to the top of the stack.<li>The memory is allocated for a specific scope, and once that scope is exited, the memory is deallocated.<li>Pros: <ul><li>Simple to implement and understand.<li>Memory allocation and deallocation is done automatically, so there is no need for manual memory management.<li>Memory is allocated and deallocated in a LIFO order, which makes it easy to keep track of memory usage.</ul><li>Cons: <ul><li>The amount of memory that can be allocated is limited by the size of the stack.<li>It’s not suitable for data that needs to be stored longer-term.<li>Recursive functions can cause stack overflow if the recursion goes too deep.</ul></ul><h4 id=heap-allocation tabindex=-1><a class=header-anchor href=#heap-allocation>Heap Allocation</a></h4><ul><li>Heap allocation refers to the process of dynamically allocating memory on the heap during runtime, as opposed to stack allocation, which takes place on the stack.<li>Heap allocation is used to allocate memory for objects that have a longer lifespan than the function call or the block in which they are created.<li>Heap allocation is performed using functions such as malloc or new in C or C++, or the operator new in Java.<li>Memory allocated on the heap is not automatically freed when the function or block in which it was allocated terminates. It must be explicitly deallocated using free or delete.<li>Heap allocation is useful when the size of the object is not known at compile time, or when the object needs to persist beyond the scope of the function or block in which it is created.<li>The advantage of heap allocation is that it provides greater flexibility in terms of memory allocation, as objects can be created and destroyed dynamically as needed.<li>However, heap allocation also requires more overhead and can result in memory leaks if objects are not properly deallocated.<li>Therefore, it is important to understand the trade-off between stack allocation and heap allocation and to choose the appropriate method based on the requirements of the program.<li>Heap allocation is also subject to fragmentation, where the available memory is split into smaller blocks, making it difficult to allocate large blocks of contiguous memory.<li>Pros: <ul><li>Provides more memory than stack<li>Offers more flexibility and control over memory<li>Ideal for large data structures and objects</ul><li>Cons: <ul><li>Slower access<li>Fragmentation can occur<li>More overhead and requires careful management</ul></ul><h3 id=5.-static-scoping-vs.-dynamic-scoping tabindex=-1><a class=header-anchor href=#5.-static-scoping-vs.-dynamic-scoping>5. Static Scoping vs. Dynamic Scoping</a></h3><iframe allow="accelerometer; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share"title="C programming | Static and Dynamic scoping | Scoping rules | Lexical scoping | Fluid Binding"allowfullscreen frameborder=0 src=https://www.youtube.com/embed/ndftEFZ5fgc></iframe><table><thead><tr><th>Feature<th>Static Scoping<th>Dynamic Scoping<tbody><tr><td>Definition<td>Based on the location of the variable definition in the source code<td>Based on the call stack at the time the variable is evaluated<tr><td>Determination of variable value<td>Closest enclosing block in which the variable is defined<td>Most recent call to a function that has defined the variable<tr><td>Debugging<td>Easier<td>More difficult<tr><td>Performance<td>Faster<td>Slower<tr><td>Typical Use<td>Most statically-typed programming languages<td>Older dynamically-typed programming languages</table><p>Static scoping and dynamic scoping are two different ways that variables in a program can be associated with values.<p>Static scoping is a scoping rule that determines the value of a variable based on the location of the variable definition in the source code. In static scoping, the value of a variable is determined by the closest enclosing block in which the variable is defined.<p>Dynamic scoping is a scoping rule that determines the value of a variable based on the call stack at the time the variable is evaluated. In dynamic scoping, the value of a variable is determined by the most recent call to a function that has defined the variable.<h3 id=6.-discuss-call-by-value-vs.-call-by-reference. tabindex=-1><a class=header-anchor href=#6.-discuss-call-by-value-vs.-call-by-reference.>6. Discuss Call by value vs. Call by reference.</a></h3><iframe allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share"title="Call By Value & Call By Reference in C"allowfullscreen frameborder=0 src=https://www.youtube.com/embed/HEiPxjVR8CU></iframe><h4 id=call-by-value tabindex=-1><a class=header-anchor href=#call-by-value>Call by value</a></h4><p>Call by value evaluates the argument expression and passes the resulting value to the function. The function receives a copy of the value, so any changes made to the argument within the function are not reflected in the caller.<p>Example Program:<pre><code class="language-c hljs"><span class=hljs-meta>#<span class=hljs-keyword>include</span> <span class=hljs-string>&LTstdio.h></span></span>

<span class=hljs-type>void</span> <span class="hljs-title function_">swap</span><span class=hljs-params>(<span class=hljs-type>int</span> x, <span class=hljs-type>int</span> y)</span>{
    <span class=hljs-type>int</span> temp = x;
    x = y;
    y = temp;
}

<span class=hljs-type>int</span> <span class="hljs-title function_">main</span><span class=hljs-params>()</span>{
    <span class=hljs-type>int</span> x = <span class=hljs-number>10</span>;
    <span class=hljs-type>int</span> y = <span class=hljs-number>11</span>;
    <span class=hljs-built_in>printf</span>(<span class=hljs-string>"Values before swap: x = %d, y = %d\n"</span>, x,y);
    swap(x,y);
    <span class=hljs-built_in>printf</span>(<span class=hljs-string>"Values after swap: x = %d, y = %d"</span>, x,y);
}
</code></pre><p>Output:<pre><code class="language-C hljs">Values before swap: x = <span class=hljs-number>10</span>, y = <span class=hljs-number>11</span>
Values after swap: x = <span class=hljs-number>10</span>, y = <span class=hljs-number>11</span>
</code></pre><h4 id=call-by-reference tabindex=-1><a class=header-anchor href=#call-by-reference>Call by reference</a></h4><p>Call by reference evaluates the argument expression and passes a reference to the resulting object to the function. The function receives a reference to the same object, so any changes made to the argument within the function are reflected in the caller.<pre><code class="language-c hljs"><span class=hljs-meta>#<span class=hljs-keyword>include</span> <span class=hljs-string>&LTstdio.h></span></span>

<span class=hljs-type>void</span> <span class="hljs-title function_">swap</span><span class=hljs-params>(<span class=hljs-type>int</span> *x, <span class=hljs-type>int</span> *y)</span>{
    <span class=hljs-type>int</span> temp = *x;
    *x = *y;
    *y = temp;
}

<span class=hljs-type>int</span> <span class="hljs-title function_">main</span><span class=hljs-params>()</span>{
    <span class=hljs-type>int</span> x = <span class=hljs-number>10</span>;
    <span class=hljs-type>int</span> y = <span class=hljs-number>11</span>;
    <span class=hljs-built_in>printf</span>(<span class=hljs-string>"Values before swap: x = %d, y = %d\n"</span>, x,y);
    swap(&x,&y);
    <span class=hljs-built_in>printf</span>(<span class=hljs-string>"Values after swap: x = %d, y = %d"</span>, x,y);
}
</code></pre><p>Output:<pre><code class="language-C hljs">Values before swap: x = <span class=hljs-number>10</span>, y = <span class=hljs-number>11</span>
Values after swap: x = <span class=hljs-number>11</span>, y = <span class=hljs-number>10</span>
</code></pre><h4 id=difference-between-call-by-value-and-call-by-reference-in-c tabindex=-1><a class=header-anchor href=#difference-between-call-by-value-and-call-by-reference-in-c>Difference Between Call by Value and Call by Reference in C</a></h4><table><thead><tr><th>Calling by Value<th>Calling by Reference<tbody><tr><td>Copies the value of an object.<td>Pass a pointer that contains the memory address of an object that gives access to its contents.<tr><td>Guarantees that changes that alter the state of the parameter will only affect the named parameter bounded by the scope of the function.<td>Changes that alter the state of the parameter will reflect to the contents of the passed object.<tr><td>Simpler to implement and simpler to reason with.<td>More difficult to keep track of changing values that happens for each time a function may be called.</table><h3 id=7.-types-of-binding-in-programming-languages tabindex=-1><a class=header-anchor href=#7.-types-of-binding-in-programming-languages>7. Types of binding in Programming Languages</a></h3><h4 id=static-binding tabindex=-1><a class=header-anchor href=#static-binding>Static binding</a></h4><ul><li>Occurs at compile-time, before the program is executed.<li>Assigns the memory location of the variable or function during the compilation process.<li>Also known as early binding or compile-time binding.<li>The type of the variable or function is determined at compile-time and cannot be changed at runtime.<li>Example:</ul><pre><code class="language-cpp hljs"><span class=hljs-type>int</span> = <span class=hljs-number>5</span>
</code></pre><h4 id=dynamic-binding tabindex=-1><a class=header-anchor href=#dynamic-binding>Dynamic binding</a></h4><ul><li>Occurs at runtime, when the program is executed.<li>Assigns the memory location of the variable or function during the execution of the program.<li>Also known as late binding or runtime binding.<li>The type of the variable or function can be determined at runtime.<li>Example:<pre><code class="language-cpp hljs"><span class=hljs-type>int</span> x = <span class=hljs-number>5</span>;
x = <span class=hljs-number>7</span>;
</code></pre></ul><h3 id=8.-write-a-note-on-naming-and-scoping-rules-for-scripting-languages. tabindex=-1><a class=header-anchor href=#8.-write-a-note-on-naming-and-scoping-rules-for-scripting-languages.>8. Write a note on Naming and Scoping rules for scripting languages.</a></h3><h4 id=naming tabindex=-1><a class=header-anchor href=#naming>Naming</a></h4><ul><li>Naming rules in scripting languages generally allow for the use of letters, digits, and underscore characters in variable names, with the first character being a letter or underscore.<li>Names are case-sensitive and cannot be reserved words.</ul><h4 id=scoping tabindex=-1><a class=header-anchor href=#scoping>Scoping</a></h4><ul><li>Scoping rules determine the visibility and accessibility of variables and functions within the program.<li>There are two types of scoping in scripting languages: local and global scoping.<li>Local scoping means variables are only accessible within a function or block of code.<li>Global scoping means variables are accessible throughout the entire program.</ul><p>It’s important to be mindful of naming and scoping rules as incorrect use can lead to unexpected results or errors.<h3 id=9.-describe-different-parameter-passing-modes. tabindex=-1><a class=header-anchor href=#9.-describe-different-parameter-passing-modes.>9. Describe different parameter passing modes.</a></h3><p>Parameter passing modes refer to the ways in which arguments or parameters are passed to a function when it’s called. There are four common parameter passing modes in programming:<ol><li><p>Call by value: This is the simplest and most common mode of parameter passing. In call by value, a copy of the argument is made and passed to the function. Any changes made to the argument inside the function have no effect on the original argument outside the function.</p><li><p>Call by reference: In call by reference, the address of the argument is passed to the function. This means that the function can modify the original argument, which will be reflected outside the function.</p><li><p>Call by pointer: This is similar to call by reference, but the argument is passed as a pointer rather than a reference. The function receives the address of the argument, so it can access and modify the original argument.</p><li><p>Call by const reference: This is similar to call by reference, but the argument is passed as a constant reference. This means that the function can access the argument, but cannot modify it.</p></ol><h3 id=10.-compare-heap-based-and-stack-based-principal-storage-allocation-mechanism. tabindex=-1><a class=header-anchor href=#10.-compare-heap-based-and-stack-based-principal-storage-allocation-mechanism.>10. Compare heap based and stack-based principal storage allocation mechanism.</a></h3><table><thead><tr><th><th>Heap-based<th>Stack-based<tbody><tr><td>Definition<td>Dynamic memory allocation mechanism in which memory is allocated at runtime and can grow or shrink as needed<td>Dynamic memory allocation mechanism in which memory is allocated in a contiguous block and follows the Last-In-First-Out (LIFO) order<tr><td>Usage<td>Used for data that needs to persist after the function call is complete<td>Used for data that is required only for the duration of the function call<tr><td>Accessibility<td>Memory in the heap can be accessed anywhere in the program<td>Memory in the stack can only be accessed within the function it was allocated in<tr><td>Allocation and Deallocation<td>Allocation and deallocation of memory in the heap can be slow and must be managed explicitly<td>Allocation and deallocation of memory in the stack is fast and is managed automatically by the program<tr><td>Flexibility<td>The heap offers more flexibility in terms of size and can be resized dynamically<td>The size of the stack is fixed and cannot be resized dynamically<tr><td>Fragmentation<td>The heap can suffer from fragmentation if blocks of memory are frequently allocated and deallocated<td>The stack does not suffer from fragmentation<tr><td>Possibility of Memory Leaks<td>The heap is more prone to memory leaks, since it is not automatically managed<td>The stack is less prone to memory leaks, since it is automatically managed</table><h3 id=11.-discuss-scope-with-reference-to-binding-in-program.-also-compare-static-and-dynamic-scoping. tabindex=-1><a class=header-anchor href=#11.-discuss-scope-with-reference-to-binding-in-program.-also-compare-static-and-dynamic-scoping.>11. Discuss Scope with reference to binding in program. Also compare static and dynamic scoping.</a></h3><p><strong>Scope</strong> refers to the part of the program in which a particular identifier or variable is accessible or visible. In other words, scope defines the region of the program where a variable can be referred to by its name.<p><strong>Binding</strong> refers to the association of a variable or identifier with a value. The process of binding a variable to a value is called variable initialization.<table><thead><tr><th>Feature<th>Static Scoping<th>Dynamic Scoping<tbody><tr><td>Definition<td>Scoping based on the position in the source code at compile time<td>Scoping based on the sequence of function calls at runtime<tr><td>Scope Determination<td>Compile Time<td>Runtime<tr><td>Variable Accessibility<td>Within the block in which it was declared and any nested blocks<td>Anywhere within the program as long as its containing function has been called<tr><td>Example Languages<td>C, Java, Python<td>Common Lisp<tr><td>Advantages<td>Easier to understand, less prone to errors<td>Useful for global variables that need to be accessible from anywhere in the program<tr><td>Disadvantages<td>Limited accessibility of variables<td>More complex and prone to errors</table><h3 id=12.-justify-the-following-statement%2C-%E2%80%9Cno-single-factor-determines-whether-a-programming-language-is-good.%E2%80%9D tabindex=-1><a class=header-anchor href=#12.-justify-the-following-statement%2C-%E2%80%9Cno-single-factor-determines-whether-a-programming-language-is-good.%E2%80%9D>12. Justify the following statement, “No single factor determines whether a programming language is good.”</a></h3><p>The statement “No single factor determines whether a programming language is good” is accurate because the quality of a programming language is determined by a combination of many factors, rather than just one. Some of the factors that influence the quality of a programming language include:<ol><li><p>Expressiveness: How easily and efficiently can complex concepts be expressed in the language?</p><li><p>Readability: How easily can the code written in the language be understood by other programmers?</p><li><p>Performance: How efficiently does the language execute code and handle large amounts of data?</p><li><p>Interoperability: How easily does the language integrate with other systems and programming languages?</p><li><p>Ecosystem: How rich and supportive is the community of users, libraries, and tools around the language?</p><li><p>Portability: How easily can code written in the language be run on different platforms and devices?</p><li><p>Maturity: How long has the language been in use and how well established is it in the industry?</p></ol><p>It is difficult to determine which programming language is best because each language excels in some areas and falls short in others. The best choice of programming language depends on the specific requirements of the project, the goals of the developer, and personal preferences.<p>Therefore, no single factor can determine whether a programming language is good, and it is more accurate to say that the quality of a programming language is determined by a combination of many factors.<h2 id=module-2 tabindex=-1><a class=header-anchor href=#module-2>Module 2</a></h2><h3 id=1.-explain-type-and-type-classes-in-haskell. tabindex=-1><a class=header-anchor href=#1.-explain-type-and-type-classes-in-haskell.>1. Explain Type and Type classes in Haskell.</a></h3><p>In Haskell, a “type” refers to a category of values that have the same kind of behavior or operations defined for them. A type is used to ensure that values of different categories are not mixed together accidentally in a program.<p>A “type class” is a collection of types that support a particular set of operations. Type classes in Haskell provide a way to define the behavior of types in a general and reusable way. For example, the Eq type class provides a definition for equality comparison (== and /=) for its instances, which include basic types like integers and floating-point numbers, as well as custom types.<p>Type classes are declared using the keyword class followed by the type class name and its associated operations, and then specifying which types are instances of the type class using the keyword instance.<h3 id=2.-what-is-composite-data-type%3F-explain-different-composite-data-types-in-haskell. tabindex=-1><a class=header-anchor href=#2.-what-is-composite-data-type%3F-explain-different-composite-data-types-in-haskell.>2. What is composite data type? Explain different composite data types in Haskell.</a></h3><p>Composite data type is a type that consists of multiple values of different data types combined together into a single entity. In Haskell, the following are some of the commonly used composite data types:<ol><li>Tuples: A tuple is a fixed-size collection of values of different types, separated by commas and enclosed in parentheses.<li>Lists: A list is an ordered collection of values of the same type. Lists are represented by square brackets and the values are separated by commas.<li>Arrays: An array is a fixed-size collection of values of the same type, stored in contiguous memory locations.<li>Records: A record is a composite data type that consists of a set of named values. The values can be of different types.<li>Algebraic data types: Algebraic data types are composite data types that can take on multiple values. For example, the type <code>Maybe</code> can take on the values <code>Just a</code> or <code>Nothing</code>.</ol><h3 id=4.-lambda-calculus tabindex=-1><a class=header-anchor href=#4.-lambda-calculus>4. Lambda Calculus</a></h3><ul><li><p>Lambda calculus is a formal system for expressing computation based on the concept of lambda functions. It was introduced by Alonzo Church in the 1930s as a mathematical tool for studying the foundations of mathematics and logic.</p><li><p>A lambda function is a function without a name, also known as an anonymous function. It consists of three parts:</p><li><p>The lambda keyword, which indicates that the function is anonymous.</p><li><p>A list of one or more variables, which represent the function’s arguments.</p><li><p>An expression, which represents the function’s body. The syntax for a lambda function is as follows:</p> <pre><code>λx.x + 1
</code></pre> <p>Here, λ is the lambda keyword, x is the variable, and x+1 is the expression.</p><li><p>In lambda calculus, functions are first-class citizens, which means they can be passed as arguments and returned as values. This makes it a powerful tool for functional programming languages like Lisp, Scheme, and Haskell.</p><li><p>Lambda calculus can be used to express a wide range of computations, including recursive functions, and it forms the theoretical basis for many programming languages.</p></ul><h3 id=5.-what-is-pattern-matching-in-haskell.-explain-with-an-example. tabindex=-1><a class=header-anchor href=#5.-what-is-pattern-matching-in-haskell.-explain-with-an-example.>5. What is pattern matching in Haskell. Explain with an example.</a></h3><p>We use pattern matching in Haskell to simplify our codes by identifying specific types of expression. We can also use if-else as an alternative to pattern matching.<p>In pattern matching, we match an expression against a series of patterns. If a match is found, the corresponding code block is executed. If no match is found, a runtime error is generated.<pre><code class="language-haskell hljs"><span class=hljs-title>sq</span> :: <span class=hljs-type>Int</span> -> <span class=hljs-type>Int</span> 
<span class=hljs-title>sq</span> <span class=hljs-number>0</span> = <span class=hljs-number>1</span> <span class=hljs-comment>--first pattern</span>
<span class=hljs-title>sq</span> n = n * n <span class=hljs-comment>-- second pattern</span>

<span class=hljs-title>main</span> = <span class=hljs-keyword>do</span> 
   putStrLn <span class=hljs-string>"The square of 5 is:"</span> <span class=hljs-comment>-- adding text decsription</span>
   print (sq <span class=hljs-number>5</span>) <span class=hljs-comment>--calling the sq function and printing output</span>
</code></pre><p>Output:<pre><code>The square of 5 is:
25
</code></pre><h3 id=6.-higher-order-function tabindex=-1><a class=header-anchor href=#6.-higher-order-function>6. Higher order function</a></h3><p>A higher-order function is a function that takes one or more functions as arguments and/or returns a function as its result. Higher-order functions are a key feature of functional programming, and they allow for a more abstract and composable approach to solving problems.<p>In simple terms, a higher-order function can either accept functions as inputs or produce a function as output, or both. By using higher-order functions, you can write more abstract, reusable, and composable code, making it easier to write, test, and maintain complex software systems.<p>Example in Python:<pre><code class="language-python hljs"><span class=hljs-keyword>def</span> <span class="hljs-title function_">square</span>(<span class=hljs-params>x</span>):
    <span class=hljs-keyword>return</span> x * x

<span class=hljs-keyword>def</span> <span class="hljs-title function_">cube</span>(<span class=hljs-params>x</span>):
    <span class=hljs-keyword>return</span> x * x * x

<span class=hljs-keyword>def</span> <span class="hljs-title function_">apply</span>(<span class=hljs-params>func, x</span>):
    <span class=hljs-keyword>return</span> func(x)

<span class=hljs-built_in>print</span>(apply(square, <span class=hljs-number>5</span>)) <span class=hljs-comment># 25</span>
<span class=hljs-built_in>print</span>(apply(cube, <span class=hljs-number>5</span>)) <span class=hljs-comment># 125</span>
</code></pre><h3 id=7.-what-mathematical-formalism-underlies-functional-programming%3F tabindex=-1><a class=header-anchor href=#7.-what-mathematical-formalism-underlies-functional-programming%3F>7. What mathematical formalism underlies functional programming?</a></h3><p>Functional programming is based on the mathematical theory of lambda calculus. Lambda calculus is a mathematical framework for defining functions and manipulating expressions. It provides a formalism for defining functions as well as operations for combining and transforming those functions. The concept of lambda calculus is central to functional programming and provides the basis for defining and manipulating functions in a functional programming language.<h3 id=8.-explain-concept-of-currying-in-haskell-with-an-example. tabindex=-1><a class=header-anchor href=#8.-explain-concept-of-currying-in-haskell-with-an-example.>8. Explain concept of currying in haskell with an example.</a></h3><iframe allow="accelerometer; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share"title="Haskell for Imperative Programmers #7 - Partial Function Application & Currying"allowfullscreen frameborder=0 src=https://www.youtube.com/embed/m12c99qgHBU></iframe><p>Currying is the process of transforming a function that takes multiple arguments in a tuple as its argument, into a function that takes just a single argument and returns another function which accepts further arguments, one by one, that the original function would receive in the rest of that tuple.<pre><code class="language-haskell hljs"><span class=hljs-title>f</span> :: a -> (b -> c)     <span class=hljs-comment>-- which can also be written as    f :: a -> b -> c</span>
</code></pre><h3 id=9.-explain-features-of-functional-programming-languages. tabindex=-1><a class=header-anchor href=#9.-explain-features-of-functional-programming-languages.>9. Explain features of functional programming languages.</a></h3><h4 id=immutable-data tabindex=-1><a class=header-anchor href=#immutable-data>Immutable Data</a></h4><p>Immutable Data means that you should easily able to create data structures instead of modifying ones which is already exist.<h4 id=referential-transparency tabindex=-1><a class=header-anchor href=#referential-transparency>Referential transparency</a></h4><p>Functional programs should perform operations just like as if it is for the first time. So, you will know what may or may not have happened during the program’s execution, and its side effects. In FP term it is called Referential transparency.<h4 id=modularity tabindex=-1><a class=header-anchor href=#modularity>Modularity</a></h4><p>Modular design increases productivity. Small modules can be coded quickly and have a greater chance of re-use which surely leads to faster development of programs. Apart from it, the modules can be tested separately which helps you to reduce the time spent on unit testing and debugging.<h4 id=maintainability tabindex=-1><a class=header-anchor href=#maintainability>Maintainability</a></h4><p>Maintainability is a simple term which means FP programming is easier to maintain as you don’t need to worry about accidentally changing anything outside the given function.<p>First-class function<p>‘First-class function’ is a definition, attributed to programming language entities that have no restriction on their use. Therefore, first-class functions can appear anywhere in the program.<h4 id=closure tabindex=-1><a class=header-anchor href=#closure>Closure</a></h4><p>The closure is an inner function which can access variables of parent function’s, even after the parent function has executed.<h3 id=higher-order-functions tabindex=-1><a class=header-anchor href=#higher-order-functions>Higher-order functions</a></h3><p>Higher-order functions either take other functions as arguments or return them as results.<p>Higher-order functions allow partial applications or currying. This technique applies a function to its arguments one at a time, as each application returning a new function which accepts the next argument.<h3 id=pure-function tabindex=-1><a class=header-anchor href=#pure-function>Pure function</a></h3><p>A ‘Pure function’ is a function whose inputs are declared as inputs and none of them should be hidden. The outputs are also declared as outputs.<p>Pure functions act on their parameters. It is not efficient if not returning anything. Moreover, it offers the same output for the given parameters<p><strong>Example:</strong><pre><code class="language-c hljs">Function <span class="hljs-title function_">Pure</span><span class=hljs-params>(a,b)</span>
{
	<span class=hljs-keyword>return</span> a+b;
}
</code></pre><h4 id=impure-functions tabindex=-1><a class=header-anchor href=#impure-functions>Impure functions</a></h4><p>Impure functions exactly in the opposite of pure. They have hidden inputs or output; it is called impure. Impure functions cannot be used or tested in isolation as they have dependencies.<p><strong>Example</strong><pre><code class="language-c hljs"><span class=hljs-type>int</span> z;
function <span class="hljs-title function_">notPure</span><span class=hljs-params>()</span>{
	z = z+<span class=hljs-number>10</span>;
}
</code></pre><h3 id=10.-what-is-the-difference-between-normal-order-and-applicative-order-evaluation%3F-what-is-lazy-evaluation%3F tabindex=-1><a class=header-anchor href=#10.-what-is-the-difference-between-normal-order-and-applicative-order-evaluation%3F-what-is-lazy-evaluation%3F>10. What is the difference between normal-order and applicative-order evaluation? What is lazy evaluation?</a></h3><iframe allow="accelerometer; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share"title="Functional Languages Evaluation Order"allowfullscreen frameborder=0 src=https://www.youtube.com/embed/DN32KzPvjUI></iframe> | Feature | Normal Order Evaluation | Applicative Order Evaluation | | --- | --- | --- | | Evaluation Strategy | Evaluate arguments only when needed | Evaluate all arguments first | | Computation Strategy | Lazy evaluation | Eager evaluation | | Debugging | More difficult | Easier | | Performance | Can be more efficient | Can be less efficient | | Typical Use | Functional programming languages | Imperative programming languages | <h3 id=11.-the-haskell-function-head-defined-in-prelude%2C-returns-the-first-element-of-a-list-and-throws-an-exception-when-we-try-to-apply-it-on-an-empty-list.-define-two-variants-of-this-function-(you-can-use-different-names)-that-work-exactly-like-head-function-except-in-the-case-of-an-empty-list-input-they-will-show-%5B%5D-as-output-instead-of-throwing-an-exception.-you-must-use-the-following-constructs-in-haskell-for-defining-the-functions. tabindex=-1><a class=header-anchor href=#11.-the-haskell-function-head-defined-in-prelude%2C-returns-the-first-element-of-a-list-and-throws-an-exception-when-we-try-to-apply-it-on-an-empty-list.-define-two-variants-of-this-function-(you-can-use-different-names)-that-work-exactly-like-head-function-except-in-the-case-of-an-empty-list-input-they-will-show-%5B%5D-as-output-instead-of-throwing-an-exception.-you-must-use-the-following-constructs-in-haskell-for-defining-the-functions.>11. The haskell function head defined in prelude, returns the first element of a list and throws an exception when we try to apply it on an empty list. Define two variants of this function (you can use different names) that work exactly like head function except in the case of an empty list input they will show [] as output instead of throwing an exception. You must use the following constructs in Haskell for defining the functions.</a></h3><ol><li>First implementation should make use of pattern matching.<li>Second implementation uses guard equations <br> Note: Students are not expected to write the main function and do user Io</ol><h3 id=12.-define-haskell-function-that-inputs-one-operator-%2B%2C-%2C*%2C%5E-and-two-operands-which-may-be-int%2C-integer%2C-float-or-double.-the-function-will-perform-the-operation-and-computes-the-result.-clearly-mention-the-type-signature-for-the-function. tabindex=-1><a class=header-anchor href=#12.-define-haskell-function-that-inputs-one-operator-%2B%2C-%2C*%2C%5E-and-two-operands-which-may-be-int%2C-integer%2C-float-or-double.-the-function-will-perform-the-operation-and-computes-the-result.-clearly-mention-the-type-signature-for-the-function.>12. Define Haskell function that inputs one operator +,-,*,^ and two operands which may be Int, Integer, Float or Double. The function will perform the operation and computes the result. Clearly mention the type signature for the function.</a></h3><p><strong>Note:</strong> Students are not expected to write the main function and do user IO.<h3 id=13.-define-a-haskell-function-named-%E2%80%9Caddus%E2%80%9D-that-adds-2-input-numbers. tabindex=-1><a class=header-anchor href=#13.-define-a-haskell-function-named-%E2%80%9Caddus%E2%80%9D-that-adds-2-input-numbers.>13. Define a haskell function named “addUs” that adds 2 input numbers.</a></h3><pre><code>Using this function as a building block, define a Haskell function “multiplyUs”
that multiplies two input numbers. The multiplyUs function should cater to
following:

1. Inputs may be signed numbers e.g. “multiplyUs (-2) * (3)” should result in
   “-6” and “multiplyUs (-2) * (-6)” should result in “12”
2. It should use guard expressions and recursion.
3. No need to write the main function to do user interaction writing definition
   for “addUs” and “multiplyUs” is sufficient.
</code></pre><p>Here is the definition for the <code>addUs</code> function in Haskell:<pre><code class="language-haskell hljs"><span class=hljs-title>addUs</span> :: <span class=hljs-type>Int</span> -> <span class=hljs-type>Int</span> -> <span class=hljs-type>Int</span>
<span class=hljs-title>addUs</span> a b = a + b` 
</code></pre><p>And here is the definition for the <code>multiplyUs</code> function using <code>addUs</code> as a building block:<pre><code class="language-haskell hljs"><span class=hljs-title>multiplyUs</span> :: <span class=hljs-type>Int</span> -> <span class=hljs-type>Int</span> -> <span class=hljs-type>Int</span>
<span class=hljs-title>multiplyUs</span> a <span class=hljs-number>0</span> = <span class=hljs-number>0</span>
<span class=hljs-title>multiplyUs</span> a b
  | a >= <span class=hljs-number>0</span> && b >= <span class=hljs-number>0</span> = helper a b <span class=hljs-number>0</span>
  | a >= <span class=hljs-number>0</span> && b < <span class=hljs-number>0</span> = helper a (negate b) <span class=hljs-number>0</span> * (-<span class=hljs-number>1</span>)
  | a < <span class=hljs-number>0</span> && b >= <span class=hljs-number>0</span> = helper (negate a) b <span class=hljs-number>0</span> * (-<span class=hljs-number>1</span>)
  | a < <span class=hljs-number>0</span> && b < <span class=hljs-number>0</span> = helper (negate a) (negate b) <span class=hljs-number>0</span>
  <span class=hljs-keyword>where</span>
    helper _ <span class=hljs-number>0</span> res = res
    helper a b res = helper a (b - <span class=hljs-number>1</span>) (addUs res a)`
</code></pre><h2 id=module-3 tabindex=-1><a class=header-anchor href=#module-3>Module 3</a></h2><h3 id=2.-write-following-english-statements-in-prolog.-mention-which-are-facts-and-rules. tabindex=-1><a class=header-anchor href=#2.-write-following-english-statements-in-prolog.-mention-which-are-facts-and-rules.>2. Write following English statements in Prolog. Mention which are facts and rules.</a></h3><ol><li>Ram writes a book.<li>Sham reads a book if it is written by Ram.<li>If someone reads any book then he is a scholar.<li>If someone reads a book written by Ram he is a fan of Ram.<li>Sham is fan of Ram.</ol><h3 id=4.-explain-what-are-facts%2C-rules%2C-and-queries-in-logic-programming-with-example. tabindex=-1><a class=header-anchor href=#4.-explain-what-are-facts%2C-rules%2C-and-queries-in-logic-programming-with-example.>4. Explain what are facts, rules, and queries in logic programming with example.</a></h3><p>In Prolog, a program is made up of a collection of facts and rules that describe relationships between different objects.<ol><li>Facts are simple statements that describe a relationship between one or more objects. They are represented as predicates and are used to assert information into the program. An example of a fact would be: “John is a software engineer”.</ol><pre><code class="language-prolog hljs">person(john, age(<span class=hljs-number>30</span>), job(<span class=hljs-string>'software engineer'</span>)).
</code></pre><ol start=2><li>Rules are logical statements that define how one predicate can be derived from other predicates. They are used to express more complex relationships between objects, and are represented as a head predicate followed by a body of predicates. An example of a rule would be: “If a person is older than 30 and has a job as a software engineer, then they are considered a senior software engineer.”</ol><pre><code class="language-prolog hljs">senior_software_engineer(<span class=hljs-symbol>X</span>) :- person(<span class=hljs-symbol>X</span>, age(<span class=hljs-symbol>Age</span>), job(<span class=hljs-string>'software engineer'</span>)), <span class=hljs-symbol>Age</span> > <span class=hljs-number>30.</span>
</code></pre><ol start=3><li>Queries are used to ask the Prolog program to find solutions that satisfy a given predicate. Queries are used to retrieve information from the program and are represented as predicates with variables. An example of a query would be: “Who is a senior software engineer?”. Copy code</ol><pre><code class="language-prolog hljs">?- senior_software_engineer(<span class=hljs-symbol>X</span>).
</code></pre><p>The Prolog interpreter will attempt to find a value for the variable X that makes the predicate senior_software_engineer(X) true. In this case, X will be bound to the value ‘john’ if the previously defined rule and fact are present in the knowledge base.<p>In summary, facts are used to assert information, rules are used to express complex relationships, and queries are used to retrieve information from the program. Prolog uses a reasoning engine to deduce the solution based on the facts and rules provided and the queries made by the user.<h3 id=5.-describe-the-difference-between-forward-chaining-and-backward-chaining.-which-is-used-in-prolog-by-default%3F tabindex=-1><a class=header-anchor href=#5.-describe-the-difference-between-forward-chaining-and-backward-chaining.-which-is-used-in-prolog-by-default%3F>5. Describe the difference between forward chaining and backward chaining. Which is used in Prolog by default?</a></h3><table><thead><tr><th>Forward Chaining<th>Backward Chaining<tbody><tr><td>Forward chaining starts from known facts and applies inference rule to extract more data unit it reaches to the goal.<td>Backward chaining starts from the goal and works backward through inference rules to find the required facts that support the goal.<tr><td>It is a bottom-up approach<td>It is a top-down approach<tr><td>Forward chaining is known as data-driven inference technique as we reach to the goal using the available data.<td>Backward chaining is known as goal-driven technique as we start from the goal and divide into sub-goal to extract the facts.<tr><td>Forward chaining reasoning applies a breadth-first search strategy.<td>Backward chaining reasoning applies a depth-first search strategy.<tr><td>Forward chaining tests for all the available rules<td>Backward chaining only tests for few required rules.<tr><td>Forward chaining is suitable for the planning, monitoring, control, and interpretation application.<td>Backward chaining is suitable for diagnostic, prescription, and debugging application.<tr><td>Forward chaining can generate an infinite number of possible conclusions.<td>Backward chaining generates a finite number of possible conclusions.<tr><td>It operates in the forward direction.<td>It operates in the backward direction.<tr><td>Forward chaining is aimed for any conclusion.<td>Backward chaining is only aimed for the required data.</table><h3 id=6.-list-operations-in-prolog tabindex=-1><a class=header-anchor href=#6.-list-operations-in-prolog>6. List operations in Prolog</a></h3><table><thead><tr><th>Operations<th>Definition<th>Predicates<tbody><tr><td>Membership Checking<td>During this operation, we can verify whether a given element is member of specified list or not?<td>list_member(X,L)<tr><td>Length Calculation<td>With this operation, we can find the length of a list.<td>list_length(L,N)<tr><td>Concatenation<td>Concatenation is an operation which is used to join/add two lists.<td>list_concat(L1,L2,L3)<tr><td>Delete Items<td>This operation removes the specified element from a list.<td>list_delete(L1,L2,L3)<tr><td>Append Items<td>Append operation adds one list into another (as an item).<td>list_append(L1,L2,L3)<tr><td>Insert Items<td>This operation inserts a given item into a list.<td>list_insert(X,L,R)</table><h3 id=7.-explain-prolog-database-manipulation-commands-with-an-example. tabindex=-1><a class=header-anchor href=#7.-explain-prolog-database-manipulation-commands-with-an-example.>7. Explain prolog database manipulation commands with an example.</a></h3><p>In Prolog, database manipulation is typically done using a combination of predicates and rules. A predicate is a logical statement that describes a relationship between one or more objects, and a rule is a logical statement that defines how one predicate can be derived from other predicates.<p>There are two type of Database Manipulation:<h4 id=static-database-manipulation. tabindex=-1><a class=header-anchor href=#static-database-manipulation.>Static Database Manipulation.</a></h4><p>Static database manipulation refers to the process of modifying a database that is not expected to change during the execution of a program. The data is considered static, meaning it will not change after the program is started.<p>Database manipulation commands give us the power to alter the meaning of predicates while we are executing statements. Predicates whose definitions are altered during run-time are called dynamic predicates,<p>Example of static Database Manipulation:<pre><code class="language-prolog hljs">?- listing.
yes

?-assert(happy(maria)).

?- listing.
happy(maria).

?- assert(happy(vineet)).
yes

?- assert(happy(cassius)).
yes

?- assert(happy(brutus)).
yes

?- assert(happy(vineet)).
yes
</code></pre><h4 id=dynamic-database-manipulation tabindex=-1><a class=header-anchor href=#dynamic-database-manipulation>Dynamic Database Manipulation</a></h4><p>Dynamic database manipulation refers to the process of modifying a database that is expected to change during the execution of a program. The data is considered dynamic, meaning it can change during the execution of the program.<p>Database manipulation is especially useful for storing in memory evaluation results, to the effect that if we ever need to compute the same goal again in the future, we don’t have to redo the calculations: we only have to look up the asserted fact. This is called memorization or caching, and it can greatly increase computational speed.<p>Example of Dynamic Database Manipulation:<pre><code class="language-prolog hljs">:- dynamic lookup/<span class=hljs-number>3.</span>
add_and_square(<span class=hljs-symbol>X</span>,<span class=hljs-symbol>Y</span>,<span class=hljs-symbol>Res</span>) :- lookup(<span class=hljs-symbol>X</span>,<span class=hljs-symbol>Y</span>,<span class=hljs-symbol>Res</span>). !.
add_and_square(<span class=hljs-symbol>X</span>,<span class=hljs-symbol>Y</span>,<span class=hljs-symbol>Res</span>) is (<span class=hljs-symbol>X</span>+<span class=hljs-symbol>Y</span>) (<span class=hljs-symbol>X</span>+<span class=hljs-symbol>Y</span>), assert(lookup(<span class=hljs-symbol>X</span>,<span class=hljs-symbol>Y</span>.<span class=hljs-symbol>Res</span>)).
</code></pre><h3 id=8.-why-do-we-use-%E2%80%9Cis%E2%80%9D-instead-of-%E2%80%9C%3D%E2%80%9D-in-prolog%3F tabindex=-1><a class=header-anchor href=#8.-why-do-we-use-%E2%80%9Cis%E2%80%9D-instead-of-%E2%80%9C%3D%E2%80%9D-in-prolog%3F>8. Why do we use “is” instead of “=” in prolog?</a></h3><p>In Prolog, the <code>is</code> operator is used to evaluate an arithmetic expression and bind the result to a variable, while the <code>=</code> operator is used to perform unification between two terms.<p>For example, the following code:<pre><code class="language-prolog hljs"><span class=hljs-string>`X is 2 + 2.`</span> 
</code></pre><p>evaluates the expression <code>2 + 2</code> and binds the result to the variable <code>X</code>. So, the query <code>X = 4</code> would return <code>true</code>.<h3 id=9.-write-a-prolog-code-to-find-if-a-list-is-sorted-or-not. tabindex=-1><a class=header-anchor href=#9.-write-a-prolog-code-to-find-if-a-list-is-sorted-or-not.>9. Write a prolog code to find if a list is sorted or not.</a></h3><pre><code class="language-prolog hljs">sorted(<span class=hljs-symbol>L</span>) :- sorted(<span class=hljs-symbol>L</span>, <span class=hljs-symbol>_</span>).

sorted([], <span class=hljs-symbol>_</span>).
sorted([<span class=hljs-symbol>_</span>], <span class=hljs-symbol>_</span>) :- !.
sorted([<span class=hljs-symbol>X</span>,<span class=hljs-symbol>X</span>|<span class=hljs-symbol>R</span>], <span class=hljs-symbol>Order</span>) :- !, sorted([<span class=hljs-symbol>X</span>|<span class=hljs-symbol>R</span>], <span class=hljs-symbol>Order</span>).
sorted([<span class=hljs-symbol>X</span>,<span class=hljs-symbol>Y</span>|<span class=hljs-symbol>R</span>], <span class=hljs-symbol>Order</span>) :- compare(<span class=hljs-symbol>Order</span>, <span class=hljs-symbol>X</span>, <span class=hljs-symbol>Y</span>), sorted([<span class=hljs-symbol>Y</span>|<span class=hljs-symbol>R</span>], <span class=hljs-symbol>Order</span>).
</code></pre><p>CLI Output:<pre><code>?- sorted([ann, bob, coy]).
true.

?- sorted([coy, bob, dan, bob, ann]).
false.
</code></pre><h3 id=10.-briefly-describe-the-process-of-resolution-and-unification-in-logic-programming-with-example. tabindex=-1><a class=header-anchor href=#10.-briefly-describe-the-process-of-resolution-and-unification-in-logic-programming-with-example.>10. Briefly describe the process of resolution and unification in logic programming with example.</a></h3><p>Resolution and unification are the central processes in logic programming, especially in Prolog.<ol><li><p>Resolution: Resolution is the process of finding a solution to a query by searching through the knowledge base (rules and facts) to find a proof. The goal is to find a set of rules and facts that logically support the query.</p><li><p>Unification: Unification is the process of finding a common solution between two expressions. In Prolog, unification is used to match the query against the rules in the knowledge base, to determine if the query can be proven.</p></ol><p>Unification Example:<pre><code class="language-prolog hljs">?- a = b.
?- f(<span class=hljs-symbol>X</span>, b) = f(a, <span class=hljs-symbol>Y</span>).
?- f(<span class=hljs-symbol>X</span>, b) = g(<span class=hljs-symbol>X</span>, b).
?- a(<span class=hljs-symbol>X</span>, <span class=hljs-symbol>X</span>, b) = a(b, <span class=hljs-symbol>X</span>, <span class=hljs-symbol>X</span>).
?- a(<span class=hljs-symbol>X</span>, <span class=hljs-symbol>X</span>, b) = a(c, <span class=hljs-symbol>X</span>, <span class=hljs-symbol>X</span>).
?- a(<span class=hljs-symbol>X</span>, f) = a(<span class=hljs-symbol>X</span>, f).
</code></pre><h3 id=11.-explain-how-prolog-differs-from-imperative-languages-in-its-handling-of-arithmetic. tabindex=-1><a class=header-anchor href=#11.-explain-how-prolog-differs-from-imperative-languages-in-its-handling-of-arithmetic.>11. Explain how Prolog differs from imperative languages in its handling of arithmetic.</a></h3><p>Prolog and imperative languages differ in their handling of arithmetic in the following ways:<ol><li>Evaluation order: In imperative languages, arithmetic expressions are evaluated following the standard operator precedence rules. In Prolog, arithmetic expressions are evaluated based on the logic rules of the program and the values of variables, not necessarily in the order they are written.<li>Variables: In imperative languages, variables can be assigned values, and the values can be updated. In Prolog, variables are used to represent relationships between values, and the values of variables cannot be updated.<li>State: Imperative languages have a notion of state, where the values of variables can change as the program executes. Prolog, on the other hand, is a declarative language and does not have a notion of state.<li>Control flow: Imperative languages control the flow of execution through the use of conditionals and loops. In Prolog, control flow is determined by the relationships between variables and the logic rules of the program.<li>Input/Output: Imperative languages often have explicit input/output statements. In Prolog, input/output is performed through queries to the knowledge base, and the results of these queries can be used to further determine the values of variables.</ol><h3 id=12.-explain-what-are-facts%2C-rules%2C-and-queries-in-logic-programming-with-example. tabindex=-1><a class=header-anchor href=#12.-explain-what-are-facts%2C-rules%2C-and-queries-in-logic-programming-with-example.>12. Explain what are facts, rules, and queries in logic programming with example.</a></h3><p>In Prolog, a program is made up of a collection of facts and rules that describe relationships between different objects.<ol><li>Facts are simple statements that describe a relationship between one or more objects. They are represented as predicates and are used to assert information into the program. An example of a fact would be: “John is a software engineer”.</ol><pre><code class="language-prolog hljs">person(john, age(<span class=hljs-number>30</span>), job(<span class=hljs-string>'software engineer'</span>)).
</code></pre><ol start=2><li>Rules are logical statements that define how one predicate can be derived from other predicates. They are used to express more complex relationships between objects, and are represented as a head predicate followed by a body of predicates. An example of a rule would be: “If a person is older than 30 and has a job as a software engineer, then they are considered a senior software engineer.”</ol><pre><code class="language-prolog hljs">senior_software_engineer(<span class=hljs-symbol>X</span>) :- person(<span class=hljs-symbol>X</span>, age(<span class=hljs-symbol>Age</span>), job(<span class=hljs-string>'software engineer'</span>)), <span class=hljs-symbol>Age</span> > <span class=hljs-number>30.</span>
</code></pre><ol start=3><li>Queries are used to ask the Prolog program to find solutions that satisfy a given predicate. Queries are used to retrieve information from the program and are represented as predicates with variables. An example of a query would be: “Who is a senior software engineer?”. Copy code</ol><pre><code class="language-prolog hljs">?- senior_software_engineer(<span class=hljs-symbol>X</span>).
</code></pre><p>The Prolog interpreter will attempt to find a value for the variable X that makes the predicate senior_software_engineer(X) true. In this case, X will be bound to the value ‘john’ if the previously defined rule and fact are present in the knowledge base.<p>In summary, facts are used to assert information, rules are used to express complex relationships, and queries are used to retrieve information from the program. Prolog uses a reasoning engine to deduce the solution based on the facts and rules provided and the queries made by the user.</div></div></main><footer class="text-center text-sm p-10 max-h-2em col-start-2"><p><a href=https://AnzenKodo.github.io/license>LICENSE</a> <span class=mx-3>|</span> <a href=#main>Back to Top</a></footer></div>